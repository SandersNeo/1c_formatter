На входе у нас есть токенизация -  таблица токенов.

Таблица токенов имеет следующую структуру:
	Парсер_Токены = Новый ТаблицаЗначений;
	Парсер_Токены.Колонки.Добавить("Индекс", Новый ОписаниеТипов("Число"));
	Парсер_Токены.Колонки.Добавить("Токен", Новый ОписаниеТипов("Строка"));
	Парсер_Токены.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"));
	Парсер_Токены.Колонки.Добавить("НомерКолонки", Новый ОписаниеТипов("Число"));
	Парсер_Токены.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	Парсер_Токены.Колонки.Добавить("Длина", Новый ОписаниеТипов("Число"));

Типы токенов, с которыми мы будем иметь дело (внутри методов токенизатора): 

Функция КлючевыеСлова() Экспорт
	Возврат Перечисление(Новый Структура,
		"Если.If, Тогда.Then, ИначеЕсли.ElsIf, Иначе.Else, КонецЕсли.EndIf,
		|Для.For, Каждого.Each, Из.In, По.To, Пока.While, Цикл.Do, КонецЦикла.EndDo,
		|Перем.Var, Знач.Val, Возврат.Return, Продолжить.Continue, Прервать.Break,
		|И.And, Или.Or, Не.Not, ДобавитьОбработчик.AddHandler, УдалитьОбработчик.RemoveHandler,
		|Попытка.Try, Исключение.Except, ВызватьИсключение.Raise, КонецПопытки.EndTry,
		|Новый.New, Выполнить.Execute, Экспорт.Export, Перейти.Goto,
		|Асинх.Async, Ждать.Await,
		|Истина.True, Ложь.False, Неопределено.Undefined, Null"
	);
КонецФункции // КлючевыеСлова()
в этой функции имена токенов - это русскоязычные наименования до точки.

Функция Токены(КлючевыеСлова = Неопределено) Экспорт
	Перем Токены;

	Если КлючевыеСлова = Неопределено Тогда
		КлючевыеСлова = КлючевыеСлова();
	КонецЕсли;

	Токены = Перечисление(Новый Структура(КлючевыеСлова),

		// Литералы

		"Идентификатор, Число, Строка, ДатаВремя,
		// Элементы строк
		|НачалоСтроки, ПродолжениеСтроки, ОкончаниеСтроки,

		// Операции

		//       =           <>           <           >
		|ЗнакРавно, ЗнакНеРавно, ЗнакМеньше, ЗнакБольше,
		//               <=                  >=
		|ЗнакМеньшеИлиРавно, ЗнакБольшеИлиРавно,
		//          +              -              *            /            %
		|ЗнакСложения, ЗнакВычитания, ЗнакУмножения, ЗнакДеления, ЗнакОстатка,
		//                (                    )                      [                       ]
		|ЛеваяКруглаяСкобка, ПраваяКруглаяСкобка, ЛеваяКвадратнаяСкобка, ПраваяКвадратнаяСкобка,
		//         ?        ,      .          :              ;
		|ЗнакВопроса, Запятая, Точка, Двоеточие, ТочкаСЗапятой,

		// ИнструкцииПрепроцессора
		|_Если, _ИначеЕсли, _Иначе, _КонецЕсли, _Область, _КонецОбласти,
		|_Вставка, _КонецВставки, _Удаление, _КонецУдаления, 

		// Другие

		//                  //      ~          &          &
		|ПустаяСтрока, Комментарий, Метка, НачалоТекста, КонецТекста,"

	);

	Возврат Токены;
КонецФункции // Токены()

Нас не интересуют токены объявления методов (процедур и функций) - они уже обрабатываются на другом уровне.

Ниже описана структура данных, которая получается на основе таблицы токенов (группировка токенов в упрощенное AST).

## 1. Блок кода из последовательно выполняемых элементов

```bsl
СтруктураБлокКода = Новый Структура(
  "ВидБлока",    "БлокКода",
  "Элементы",        Массив<Блок>    // любой вложенный код
);
```

Здесь `Блок` — это один из типов:

- БлокЛогическойСтроки  
- БлокЕсли  
- БлокПока  
- БлокДля  
- БлокДляКаждого  
- БлокПопытка  
- БлокИсключение  

---

## 2. Базовые блоки

### 2.1. Логическая строка

Одно выражение (блок токенов), заканчивающееся точкой‑с‑запятой (или концом кода/КонецЕсли, Тогда и т.д.). Может представлять собой метку или инструкцию препроцессора (#Если условие Тогда, и прочие, где токен начинается на "_")

```bsl
БлокЛогическойСтроки = Новый Структура(
  "ВидБлока",       "ЛогическаяСтрока",
  "НачИндекс",  НачИндексТокена,
  "КонИндекс",  КонИндексТокена
);
```

### 2.2. Комментарий

Непрерывный блок строк комментариев, найденный вне логической строки

```bsl
БлокКомментарий = Новый Структура(
  "ВидБлока",       "Комментарий",
  "НачИндекс",  НачИндексТокена,
  "КонИндекс",  КонИндексТокена
);
```

### 2.3. Пустая строка

Непрерывный блок пустых строк, найденный вне логической строки

```bsl
БлокПустаяСтрока = Новый Структура(
  "ВидБлока",       "ПустаяСтрока",
  "НачИндекс",  НачИндексТокена,
  "КонИндекс",  КонИндексТокена
);
```

---

## 3. Управляющие конструкции

### 3.1. Если … Тогда … ИначеЕсли … Иначе … КонецЕсли

```bsl
БлокЕсли = Новый Структура(
  "ВидБлока",       "Если",
  "Условие",        БлокЛогическойСтроки,       // между «Если» и «Тогда»
  "Тело",           БлокКода,        // между «Тогда» и первой из веток Иначе*
  "ВеткиИначе",     Массив<Блок>         // каждый блок с ВидБлока="ИначеЕсли" или "Иначе"
);
```

```bsl
БлокИначеЕсли = Новый Структура(
  "ВидБлока",       "ИначеЕсли",
  "Условие",        БлокЛогическойСтроки,       // между «ИначеЕсли» и «Тогда»
  "Тело",           БлокКода
);
```

```bsl
БлокИначе = Новый Структура(
  "ВидБлока",       "Иначе",
  "Тело",           БлокКода
);
```

### 3.2. Пока … Цикл … КонецЦикла

```bsl
БлокПока = Новый Структура(
  "ВидБлока",       "Пока",
  "Условие",        БлокЛогическойСтроки,       // между «Пока» и «Цикл»
  "Тело",           БлокКода
);
```

### 3.3. Для … По … Цикл … КонецЦикла

```bsl
БлокДля = Новый Структура(
  "ВидБлока",       "Для",
  "Инициализация",  БлокЛогическойСтроки,       // между «Для» и «По» (счётчик+начало)
  "КонецСчётчика",  БлокЛогическойСтроки,       // между «По» и «Цикл»
  "Тело",           БлокКода
);
```

### 3.4. Для каждого … Из … Цикл … КонецЦикла

```bsl
БлокДляКаждого = Новый Структура(
  "ВидБлока",       "ДляКаждого",
  "Элемент",        БлокЛогическойСтроки,       // между «Для» и «Из»
  "Коллекция",      БлокЛогическойСтроки,       // между «Из» и «Цикл»
  "Тело",           БлокКода
);
```

---

## 4. Обработка исключений

```bsl
БлокПопытка = Новый Структура(
  "ВидБлока",       "Попытка",
  "ТелоПопытки",    БлокКода,
  "ТелоИсключения", БлокКода
);
```



## Идея организации парсера

Рекурсивный парсер можно реализовать как нисходящий (top‑down) обход последовательности токенов с сохранением контекста в стеке. Ниже приводится одна из возможных схем, ориентированная на BSL‑синтаксис и представление блоков в виде структур, описанных выше.

### 1. Общие принципы
	• Парсер работает **однопроходно** — двигается по массиву токенов слева‑направо.
	• Состояние парсера описывается кортежем `(ТекущийИндекс, СтекКонтекстов)`.
	• Каждая запись стека содержит ожидаемый завершающий токен (например `КонецЕсли`) и ссылку на формируемый блок.
	• Для построения дерева используется рекурсивная функция `РазобратьБлокКода(НачИндекс, ЗавершающиеКлючевыеСлова)`.
	• Функция возвращает кортеж `(БлокКода, СледующийИндекс)`.

### 2. Интерфейс основных функций
```bsl
Функция Разобрать(Токены) Экспорт
	Возврат РазобратьБлокКода(0, Неопределено).Блок;
КонецФункции

Функция РазобратьБлокКода(Индекс, ЗавершающиеКлючевыеСлова) Экспорт
	Перем Блок = Новый Структура("ВидБлока", "БлокКода", "Тело", Новый Массив);
	Пока Индекс < Токены.Количество() Цикл
		Перем Ток = Токены[Индекс].Токен;
		/* если встретили один из завершающих ключевых слов — возвращаемся */
		Если ЗавершающиеКлючевыеСлова <> Неопределено И ЗавершающиеКлючевыеСлова.Содержит(Ток) Тогда
			Возврат Новый Структура("Блок", Блок, "СледующийИндекс", Индекс);
		КонецЕсли;

		// 1. Комментарии, пустые строки
		Если Ток = "Комментарий" Тогда
			ДобавитьКомментарий();
		ИначеЕсли Ток = "ПустаяСтрока" Тогда
			ДобавитьПустыеСтроки();

		// 2. Управляющие конструкции
		ИначеЕсли Ток = "Если" Тогда
			{БлокЕсли, Индекс} = РазобратьЕсли(Индекс);
			Блок.Тело.Добавить(БлокЕсли);
			Продолжить;
		ИначеЕсли Ток = "Пока" Тогда
			{БлокПока, Индекс} = РазобратьПока(Индекс);
			Блок.Тело.Добавить(БлокПока);
			Продолжить;
		// ... аналогично Для, ДляКаждого, Попытка ...

		// 3. Обычная логическая строка
		Иначе
			{Строка, Индекс} = РазобратьЛогическуюСтроку(Индекс);
			Блок.Тело.Добавить(Строка);
		КонецЕсли;
	КонецЦикла;
	Возврат Новый Структура("Блок", Блок, "СледующийИндекс", Индекс);
КонецФункции // РазобратьБлокКода()
```

### 3. Разбор управляющих конструкций

#### 3.1. Если … Тогда … Иначе* … КонецЕсли
```bsl
Функция РазобратьЕсли(ИндексНач) Экспорт
	Перем БлокЕсли = Новый Структура("ВидБлока", "Если");

	// a) условие до "Тогда"
	{Условие, Индекс} = РазобратьЛогическуюСтроку(ИндексНач + 1, КлючевоеСлово."Тогда");
	БлокЕсли.Условие = Условие;

	// b) тело между "Тогда" и первой веткой Else/КонецЕсли
	{Тело, Индекс} = РазобратьБлокКода(Индекс, Новый Массив("ИначеЕсли", "Иначе", "КонецЕсли"));
	БлокЕсли.Тело = Тело;

	// c) последующие ветки
	Перем Ветки = Новый Массив;
	Пока Токены[Индекс].Токен = "ИначеЕсли" Или Токены[Индекс].Токен = "Иначе" Цикл
		Если Токены[Индекс].Токен = "ИначеЕсли" Тогда
			{Ветка, Индекс} = РазобратьИначеЕсли(Индекс);
		Иначе
			{Ветка, Индекс} = РазобратьИначе(Индекс);
		КонецЕсли;
		Ветки.Добавить(Ветка);
	КонецЦикла;
	БлокЕсли.ВеткиИначе = Ветки;

	// d) пропускаем "КонецЕсли"
	Индекс = Индекс + 1;
	Возврат Новый Структура("Блок", БлокЕсли, "СледующийИндекс", Индекс);
КонецФункции
```

#### 3.2. Остальные конструкции
	• РазобратьПока, РазобратьДля, РазобратьДляКаждого, РазобратьПопытка строятся по тому же шаблону: сначала разбираем заголовочную(е) логическую строку(и), затем рекурсивно зовём РазобратьБлокКода до соответствующего завершающего слова.

### 4. Разбор логической строки
```bsl
Функция РазобратьЛогическуюСтроку(ИндексНач, КлючевоеСловоОкончания = Токен."ТочкаСЗапятой") Экспорт
	Пока Индекс < Токены.Количество() И Токены[Индекс].Токен <> КлючевоеСловоОкончания Цикл
		Индекс = Индекс + 1;
	КонецЦикла;
	Перем Блок = Новый Структура("ВидБлока", "ЛогическаяСтрока", "НачИндекс", ИндексНач, "КонИндекс", Индекс);
	// пропускаем токен‑разделитель
	Если Индекс < Токены.Количество() Тогда
		Индекс = Индекс + 1;
	КонецЕсли;
	Возврат Новый Структура("Блок", Блок, "СледующийИндекс", Индекс);
КонецФункции
```

### 5. Работа с комментариями и пустыми строками
	Парсер обнаруживает непрерывные фрагменты токенов `Комментарий` и `ПустаяСтрока` вне логической строки и конвертирует их в соответствующие блоки `БлокКомментарий` и `БлокПустаяСтрока`. Алгоритм аналогичен разбору логической строки, но завершается при встрече первого **не**‑комментария / **не**‑пустой строки.

### 6. Управление рекурсией
	• Каждая вложенная конструкция порождает **новый** вызов `РазобратьБлокКода`, который заканчивается, когда встречает своё завершающее ключевое слово.
	• Таким образом глубина стека соответствует глубине вложенности управляющих конструкций в исходном коде.

### 7. Результат
	Вызов `Разобрать(Токены)` возвращает готовый корневой `БлокКода`, содержащий:
	1) Набор базовых блоков (`ЛогическаяСтрока`, `Комментарий`, `ПустаяСтрока`),
	2) Управляющие блоки, каждый из которых, в свою очередь, содержит собственный `БлокКода`.

Эта структура полностью соответствует требованиям, изложенным в разделе описания блоков, и может напрямую использоваться форматтером для применения правил оформления.

