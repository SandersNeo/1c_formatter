// Репозиторий проекта: 
// https://github.com/vladimir-kharin/1c_formatter
// 
// Харин Владимир (С) 2025. https://vharin.ru
// Telegram - https://t.me/vladimir_kharin

// Модуль оформления тела методов

// Глобальные переменные
Перем АнглСинтаксис;      // Флаг использования английского синтаксиса
Перем ТекущийОтступ;      // Текущий уровень отступа
Перем МассивЭлементовТекста; // Массив для формирования результата
Перем ТаблицаТокенов;     // Таблица токенов из парсера
Перем БазовыйОтступ;      // Строка отступа (табуляция)
Перем КлючевыеСлова;      // Таблица соответствия рус/англ ключевых слов
Перем Токены;             // Таблица токенов
Перем ИсходныйТекст;      // Исходный текст
Перем СимволыТокенов;     // Соответствие символов токенов
Перем НачатаНоваяСтрока;

// Основной метод оформления текста
//
// Параметры:
//  Текст - Строка - исходный текст для форматирования
//  _АнглСинтаксис - Булево - использовать английский синтаксис (по умолчанию Ложь)
//
// Возвращаемое значение:
//  Строка - отформатированный текст
//
Функция Оформить(Текст, _АнглСинтаксис = Ложь) Экспорт
	// Инициализация
	Инициализация();

	ИсходныйТекст = Текст;
	АнглСинтаксис = _АнглСинтаксис;
	ТекущийОтступ = 0;
	МассивЭлементовТекста = Новый Массив;
	БазовыйОтступ = Символы.Таб;
	НачатаНоваяСтрока = Истина;
	
	// Получение токенов и парсинг
	Парсер = Обработки.ОМ_Парсер_ПарсерВстроенногоЯзыка.Создать();
	ТаблицаТокенов = Парсер.Токенизировать(Текст);
	
	// Получение дерева блоков
	ПарсерДляОформления = Обработки.ОМ_Парсер_ПарсерВстроенногоЯзыкаБазовыеБоки.Создать();
	БлокКода = ПарсерДляОформления.Разобрать(ТаблицаТокенов);
	
	// Форматирование
	ОформитьБлокКода(БлокКода);
	
	// Объединение результата
    ТекстРезультат = СтрСоединить(МассивЭлементовТекста);
	
	// Убираем двойные пробелы
	ТекстРезультат = СтрЗаменить(ТекстРезультат, "  ", " ");

	Возврат ТекстРезультат;
КонецФункции

//////////////////////////////////////////////////////////////////////////////
// Базовые методы вывода

// Добавляет текст к результату
//
// Параметры:
//  Текст - Строка - текст для добавления
//
Процедура ВывестиТекст(Текст)
	Если НачатаНоваяСтрока Тогда
		ВывестиОтступ();
		НачатаНоваяСтрока = Ложь;
	КонецЕсли;

	МассивЭлементовТекста.Добавить(Текст);
КонецПроцедуры

// Выводит многострочный текст с отступами
//
// Параметры:
//  Текст - Строка - текст для вывода
//
Процедура ВывестиМногострочныйТекст(Текст)
	КоличествоСтрок = СтрЧислоСтрок(Текст);
	
	Для Счетчик = 1 По КоличествоСтрок Цикл
		Строка = СтрПолучитьСтроку(Текст, Счетчик);
		ВывестиТекст(Строка);
		Если Счетчик < КоличествоСтрок Тогда
			НачатьНовуюСтроку();
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Выводит текущий отступ
//
Процедура ВывестиОтступ()
	Для Счетчик = 1 По ТекущийОтступ Цикл
		МассивЭлементовТекста.Добавить(БазовыйОтступ);
	КонецЦикла;
КонецПроцедуры

// Добавляет перевод строки
//
Процедура ВывестиПереводСтроки()
	МассивЭлементовТекста.Добавить(Символы.ПС);
КонецПроцедуры

// Добавляет перевод строки и отступ
//
Процедура НачатьНовуюСтроку()
	ВывестиПереводСтроки();
	НачатаНоваяСтрока = Истина;
КонецПроцедуры

// Выводит ключевое слово с учетом языка
//
// Параметры:
//  КлючевоеСлово - Строка - ключевое слово для вывода
//
Процедура ВывестиКлючевоеСлово(КлючевоеСлово)
	ВывестиТекст(ТекстКлючевогоСлова(КлючевоеСлово));
КонецПроцедуры

// Возвращает содержимое токена по индексу из исходной строки
//
// Параметры:
//  Индекс - Число - индекс токена в таблице токенов
//
// Возвращаемое значение:
//  Строка - часть исходной строки, соответствующая токену
//
Функция СодержимоеТокена(Индекс)
	Токен = ТаблицаТокенов[Индекс];
	Возврат Сред(ИсходныйТекст, Токен.Позиция, Токен.Длина);
КонецФункции


// Увеличивает текущий отступ
//
Процедура УвеличитьОтступ()
	ТекущийОтступ = ТекущийОтступ + 1;
КонецПроцедуры

// Уменьшает текущий отступ
//
Процедура УменьшитьОтступ()
	ТекущийОтступ = Макс(0, ТекущийОтступ - 1);
КонецПроцедуры

// Получает текст ключевого слова с учетом языка
//
// Параметры:
//  КлючевоеСлово - Строка - ключевое слово
//
// Возвращаемое значение:
//  Строка - текст ключевого слова на нужном языке
//
Функция ТекстКлючевогоСлова(КлючевоеСлово)
	Если Не КлючевыеСлова.Свойство(КлючевоеСлово) Тогда
		Возврат КлючевоеСлово;
	КонецЕсли;
	
	ТекстЛокализации = КлючевыеСлова[КлючевоеСлово];
	
	Если АнглСинтаксис Тогда
		Возврат НСтр(ТекстЛокализации, "en");
	Иначе
		Возврат НСтр(ТекстЛокализации, "ru");
	КонецЕсли;
КонецФункции

// Получает текстовое представление токена
//
// Параметры:
//  Индекс - Число - индекс токена в таблице
//
// Возвращаемое значение:
//  Строка - текстовое представление токена
//
Функция ТекстТокена(Индекс)
	Токен = ТаблицаТокенов[Индекс].Токен;

	// Обработка ключевых слов
	Если КлючевыеСлова.Свойство(Токен) Тогда
		Возврат ТекстКлючевогоСлова(Токен);
	КонецЕсли;
	
	// Обработка токенов препроцессора (начинаются с "_")
	Если СтрНачинаетсяС(Токен, "_") Тогда
		ТокенБезПрефикса = Сред(Токен, 2);
		Локализация = ?(АнглСинтаксис, "en", "ru");
		Если ТокенБезПрефикса = "Если" Тогда
			Возврат "#" + НСтр("ru='Если';en='If'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "ИначеЕсли" Тогда
			Возврат "#" + НСтр("ru='ИначеЕсли';en='ElsIf'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "Иначе" Тогда
			Возврат "#" + НСтр("ru='Иначе';en='Else'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "КонецЕсли" Тогда
			Возврат "#" + НСтр("ru='КонецЕсли';en='EndIf'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "Область" Тогда
			Возврат "#" + НСтр("ru='Область';en='Region'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "КонецОбласти" Тогда
			Возврат "#" + НСтр("ru='КонецОбласти';en='EndRegion'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "Вставка" Тогда
			Возврат "#" + НСтр("ru='Вставка';en='Insert'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "КонецВставки" Тогда
			Возврат "#" + НСтр("ru='КонецВставки';en='EndInsert'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "Удаление" Тогда
			Возврат "#" + НСтр("ru='Удаление';en='Delete'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "КонецУдаления" Тогда
			Возврат "#" + НСтр("ru='КонецУдаления';en='EndDelete'", Локализация);
		Иначе
			ВызватьИсключение СтрШаблон("Неизвестный токен препроцессора: %1", Токен);
		КонецЕсли;
	КонецЕсли;
	
	// Обработка литералов и специальных токенов
	Если Токен = "Идентификатор" 
		ИЛИ Токен = "Число" 
		ИЛИ Токен = "Строка" 
		ИЛИ Токен = "ДатаВремя" 
		ИЛИ Токен = "ОкончаниеСтроки" 
	Тогда
		Возврат СодержимоеТокена(Индекс);
	ИначеЕсли Токен = "Комментарий" Тогда
		Возврат "//" + СодержимоеТокена(Индекс);
	ИначеЕсли Токен = "НачалоСтроки"
		ИЛИ Токен = "ПродолжениеСтроки" Тогда
		Возврат СокрП(СодержимоеТокена(Индекс));
	ИначеЕсли Токен = "Метка" Тогда
		Возврат СодержимоеТокена(Индекс) + ":";
	КонецЕсли;
	
	// Используем глобальную переменную СимволыТокенов
	// Проверяем, есть ли соответствие для токена
	Если СимволыТокенов[Токен] <> Неопределено Тогда
		Возврат СимволыТокенов[Токен];
	КонецЕсли;
	
	// Если это неизвестный токен, выбрасываем исключение
	ВызватьИсключение СтрШаблон("Неизвестный токен: %1", Токен);
КонецФункции

//////////////////////////////////////////////////////////////////////////////
// Методы форматирования блоков

// Форматирует блок кода (рекурсивный обход всех элементов)
//
// Параметры:
//  БлокКода - Структура - блок кода для форматирования
//
Процедура ОформитьБлокКода(БлокКода)
	Если БлокКода = Неопределено ИЛИ БлокКода.Элементы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	БлокПредыдущий = Неопределено;
	
	Для Каждого Блок Из БлокКода.Элементы Цикл
		// Форматируем блок
		ОформитьБлок(Блок);
	КонецЦикла;
КонецПроцедуры

// Определяет тип блока и вызывает соответствующий метод форматирования
//
// Параметры:
//  Блок - Структура - блок для форматирования
//
Процедура ОформитьБлок(Блок)
	Если Блок = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ВидБлока = Блок.ВидБлока;
	
	Если ВидБлока = "БлокКода" Тогда
		ОформитьБлокКода(Блок);
	ИначеЕсли ВидБлока = "ЛогическаяСтрока" Тогда
		ОформитьБлокЛогическойСтроки(Блок);
	ИначеЕсли ВидБлока = "Комментарий" Тогда
		ОформитьБлокКомментария(Блок);
	ИначеЕсли ВидБлока = "ПустаяСтрока" Тогда
		ОформитьБлокПустойСтроки(Блок);
	ИначеЕсли ВидБлока = "Если" Тогда
		ОформитьБлокЕсли(Блок);
	ИначеЕсли ВидБлока = "ИначеЕсли" Тогда
		ОформитьБлокИначеЕсли(Блок);
	ИначеЕсли ВидБлока = "Иначе" Тогда
		ОформитьБлокИначе(Блок);
	ИначеЕсли ВидБлока = "Пока" Тогда
		ОформитьБлокПока(Блок);
	ИначеЕсли ВидБлока = "Для" Тогда
		ОформитьБлокДля(Блок);
	ИначеЕсли ВидБлока = "ДляКаждого" Тогда
		ОформитьБлокДляКаждого(Блок);
	ИначеЕсли ВидБлока = "Попытка" Тогда
		ОформитьБлокПопытка(Блок);
	КонецЕсли;
КонецПроцедуры

// Форматирует логическую строку
//
// Параметры:
//  БлокСтроки - Структура - блок логической строки
//  ВыводитьОтступ - Булево - необходимо ли выводить отступ
//
Процедура ОформитьБлокЛогическойСтроки(БлокСтроки)
	Текст = ТекстЛогическойСтроки(БлокСтроки);
	// TODO: Вывод точки с запятой (если ее нет), а также комментария (если есть).
	ВывестиМногострочныйТекст(Текст);
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует блок комментариев
//
// Параметры:
//  БлокКомментария - Структура - блок комментария
//
Процедура ОформитьБлокКомментария(БлокКомментария)
	Для Индекс = БлокКомментария.НачИндекс По БлокКомментария.КонИндекс Цикл
		ВывестиКомментарий(Индекс);
		НачатьНовуюСтроку();
	КонецЦикла;
КонецПроцедуры

// Выводит комментарий по индексу токена
//
// Параметры:
//  Индекс - Число - индекс токена в таблице токенов
//
Процедура ВывестиКомментарий(Индекс)
	ВывестиТекст("//");
	Содержимое = СодержимоеТокена(Индекс);
	
	Если СтрДлина(Содержимое) > 0 Тогда
		ПервыйСимвол = Лев(Содержимое, 1);
		Если ПервыйСимвол <> " " И ПервыйСимвол <> Символы.Таб Тогда
			ВывестиТекст(" ");
		КонецЕсли;
	КонецЕсли;
	
	ВывестиТекст(Содержимое);
КонецПроцедуры


// Форматирует блок пустых строк
//
// Параметры:
//  БлокПустойСтроки - Структура - блок пустой строки
//
Процедура ОформитьБлокПустойСтроки(БлокПустойСтроки)
	НачатьНовуюСтроку();
КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////
// Методы форматирования управляющих конструкций

// Форматирует конструкцию Если-Тогда-ИначеЕсли-Иначе-КонецЕсли
//
// Параметры:
//  БлокЕсли - Структура - блок условия Если
//
Процедура ОформитьБлокЕсли(БлокЕсли)
	// Выводим "Если" и условие
	ВывестиКлючевоеСлово("Если");
	ВывестиТекст(" ");

	ТекстУсловие = ТекстЛогическойСтроки(БлокЕсли.Условие);
	Если СтрЧислоСтрок(ТекстУсловие) > 1 Тогда
		ВывестиМногострочныйТекст(ТекстУсловие);
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстУсловие);
		ВывестиТекст(" ");
	КонецЕсли;

	ВывестиКлючевоеСлово("Тогда");

	УвеличитьОтступ();
	НачатьНовуюСтроку();

	ОформитьБлокКода(БлокЕсли.Тело);

	УменьшитьОтступ();
	
	// Обрабатываем ветки ИначеЕсли и Иначе
	Если БлокЕсли.ВеткиИначе <> Неопределено Тогда
		Для Каждого Ветка Из БлокЕсли.ВеткиИначе Цикл
			ОформитьБлок(Ветка);
		КонецЦикла;
	КонецЕсли;
	
	// Выводим "КонецЕсли"
	ВывестиКлючевоеСлово("КонецЕсли");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию ИначеЕсли-Тогда
//
// Параметры:
//  БлокИначеЕсли - Структура - блок условия ИначеЕсли
//
Процедура ОформитьБлокИначеЕсли(БлокИначеЕсли)
	// Выводим "ИначеЕсли" и условие
	ВывестиКлючевоеСлово("ИначеЕсли");
	ВывестиТекст(" ");

	ТекстУсловие = ТекстЛогическойСтроки(БлокИначеЕсли.Условие);
	Если СтрЧислоСтрок(ТекстУсловие) > 1 Тогда
		ВывестиМногострочныйТекст(ТекстУсловие);
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстУсловие);
		ВывестиТекст(" ");
	КонецЕсли;

	ВывестиКлючевоеСлово("Тогда");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	ОформитьБлокКода(БлокИначеЕсли.Тело);
	
	УменьшитьОтступ();
КонецПроцедуры

// Форматирует конструкцию Иначе
//
// Параметры:
//  БлокИначе - Структура - блок условия Иначе
//
Процедура ОформитьБлокИначе(БлокИначе)
	// Выводим "Иначе"
	ВывестиКлючевоеСлово("Иначе");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело
	ОформитьБлокКода(БлокИначе.Тело);
	
	УменьшитьОтступ();
КонецПроцедуры

// Форматирует конструкцию Пока-Цикл-КонецЦикла
//
// Параметры:
//  БлокПока - Структура - блок цикла Пока
//
Процедура ОформитьБлокПока(БлокПока)
	// Выводим "Пока" и условие
	ВывестиКлючевоеСлово("Пока");
	ВывестиТекст(" ");

	ТекстУсловие = ТекстЛогическойСтроки(БлокПока.Условие);
	Если СтрЧислоСтрок(ТекстУсловие) > 1 Тогда
		ВывестиМногострочныйТекст(ТекстУсловие);
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстУсловие);
		ВывестиТекст(" ");
	КонецЕсли;

	ВывестиКлючевоеСлово("Цикл");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело цикла
	ОформитьБлокКода(БлокПока.Тело);
	
	УменьшитьОтступ();
	
	// Выводим "КонецЦикла"
	ВывестиКлючевоеСлово("КонецЦикла");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Для-По-Цикл-КонецЦикла
//
// Параметры:
//  БлокДля - Структура - блок цикла Для
//
Процедура ОформитьБлокДля(БлокДля)
	// Выводим "Для" и инициализацию
	ВывестиКлючевоеСлово("Для");
	ВывестиТекст(" ");
	
	ТекстИнициализация = ТекстЛогическойСтроки(БлокДля.Инициализация);
	Если СтрЧислоСтрок(ТекстИнициализация) > 1 Тогда
		ВывестиМногострочныйТекст(ТекстИнициализация);
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстИнициализация);
		ВывестиТекст(" ");
	КонецЕсли;
	
	// Выводим "По" и конечное значение
	ВывестиКлючевоеСлово("По");
	ВывестиТекст(" ");
	
	ТекстКонецСчетчика = ТекстЛогическойСтроки(БлокДля.КонецСчетчика);
	Если СтрЧислоСтрок(ТекстКонецСчетчика) > 1 Тогда
		ВывестиМногострочныйТекст(ТекстКонецСчетчика);
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстКонецСчетчика);
		ВывестиТекст(" ");
	КонецЕсли;
	
	ВывестиКлючевоеСлово("Цикл");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело цикла
	ОформитьБлокКода(БлокДля.Тело);
	
	УменьшитьОтступ();
	
	// Выводим "КонецЦикла"
	ВывестиКлючевоеСлово("КонецЦикла");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Для-Каждого-Из-Цикл-КонецЦикла
//
// Параметры:
//  БлокДляКаждого - Структура - блок цикла Для Каждого
//
Процедура ОформитьБлокДляКаждого(БлокДляКаждого)
	// Выводим "Для Каждого" и элемент
	ВывестиКлючевоеСлово("Для");
	ВывестиТекст(" ");
	ВывестиКлючевоеСлово("Каждого");
	ВывестиТекст(" ");
	
	ТекстЭлемент = ТекстЛогическойСтроки(БлокДляКаждого.Элемент);
	ВывестиТекст(ТекстЭлемент);
	ВывестиТекст(" ");
	
	// Выводим "Из" и коллекцию
	ВывестиКлючевоеСлово("Из");
	ВывестиТекст(" ");
	
	ТекстКоллекция = ТекстЛогическойСтроки(БлокДляКаждого.Коллекция);
	Если СтрЧислоСтрок(ТекстКоллекция) > 1 Тогда
		ВывестиМногострочныйТекст(ТекстКоллекция);
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстКоллекция);
		ВывестиТекст(" ");
	КонецЕсли;
	
	ВывестиКлючевоеСлово("Цикл");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело цикла
	ОформитьБлокКода(БлокДляКаждого.Тело);
	
	УменьшитьОтступ();
	
	// Выводим "КонецЦикла"
	ВывестиКлючевоеСлово("КонецЦикла");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Попытка-Исключение-КонецПопытки
//
// Параметры:
//  БлокПопытка - Структура - блок обработки исключений
//
Процедура ОформитьБлокПопытка(БлокПопытка)
	// Выводим "Попытка"
	ВывестиКлючевоеСлово("Попытка");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело попытки
	ОформитьБлокКода(БлокПопытка.ТелоПопытки);
	
	УменьшитьОтступ();
	
	// Выводим "Исключение"
	ВывестиКлючевоеСлово("Исключение");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело обработки исключения
	ОформитьБлокКода(БлокПопытка.ТелоИсключения);
	
	УменьшитьОтступ();
	
	// Выводим "КонецПопытки"
	ВывестиКлючевоеСлово("КонецПопытки");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////
// Служебные методы

// Проверяет нахождение токенов на одной строке
//
// Параметры:
//  Индекс1 - Число - индекс первого токена
//  Индекс2 - Число - индекс второго токена
//
// Возвращаемое значение:
//  Булево - Истина, если токены на одной строке
//
Функция ТокеныНаОднойСтроке(Индекс1, Индекс2)
	Если Индекс1 < 0 ИЛИ Индекс2 < 0 ИЛИ 
		Индекс1 >= ТаблицаТокенов.Количество() ИЛИ 
		Индекс2 >= ТаблицаТокенов.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТаблицаТокенов[Индекс1].НомерСтроки = ТаблицаТокенов[Индекс2].НомерСтроки;
КонецФункции

// Возвращает структуру с ключевыми словами и их переводами
//
// Возвращаемое значение:
//  Структура - ключевые слова с переводами
//
Функция КлючевыеСлова()
	СтрокаКлючевыхСлов = 
		"Если.If, Тогда.Then, ИначеЕсли.ElsIf, Иначе.Else, КонецЕсли.EndIf,
		|Для.For, Каждого.Each, Из.In, По.To, Пока.While, Цикл.Do, КонецЦикла.EndDo,
		|Процедура.Procedure, КонецПроцедуры.EndProcedure, Функция.Function, КонецФункции.EndFunction,
		|Перем.Var, Знач.Val, Возврат.Return, Продолжить.Continue, Прервать.Break,
		|И.And, Или.Or, Не.Not, ДобавитьОбработчик.AddHandler, УдалитьОбработчик.RemoveHandler,
		|Попытка.Try, Исключение.Except, ВызватьИсключение.Raise, КонецПопытки.EndTry,
		|Новый.New, Выполнить.Execute, Экспорт.Export, Перейти.Goto,
		|Асинх.Async, Ждать.Await,
		|Истина.True, Ложь.False, Неопределено.Undefined, Null";
	
	Результат = Новый Структура;
	
	// Разбиваем строку на элементы по запятой
	МассивЭлементов = СтрРазделить(СтрокаКлючевыхСлов, ",", Ложь);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		ОчищенныйЭлемент = СокрЛП(Элемент);
		
		// Разбиваем на русское и английское слово
		МассивСлов = СтрРазделить(ОчищенныйЭлемент, ".", Ложь);
		
		Если МассивСлов.Количество() >= 2 Тогда
			РусскоеСлово = СокрЛП(МассивСлов[0]);
			АнглийскоеСлово = СокрЛП(МассивСлов[1]);
		Иначе
			// Если только один элемент, используем его и для русского и для английского
			РусскоеСлово = СокрЛП(МассивСлов[0]);
			АнглийскоеСлово = РусскоеСлово;
		КонецЕсли;
		
		// Формируем значение в требуемом формате
		ЗначениеСтруктуры = СтрШаблон("ru='%1';en='%2'", РусскоеСлово, АнглийскоеСлово);
		
		// Добавляем в структуру
		Результат.Вставить(РусскоеСлово, ЗначениеСтруктуры);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с токенами
//
// Параметры:
//  КлючевыеСлова - Структура - структура с ключевыми словами
//
// Возвращаемое значение:
//  Структура - токены языка
//
Функция Токены(КлючевыеСлова)
	ДополнительныеТокены = 
		"Идентификатор, Число, Строка, ДатаВремя,
		// Элементы строк
		|НачалоСтроки, ПродолжениеСтроки, ОкончаниеСтроки,

		// Операции

		//       =           <>           <           >
		|ЗнакРавно, ЗнакНеРавно, ЗнакМеньше, ЗнакБольше,
		//               <=                  >=
		|ЗнакМеньшеИлиРавно, ЗнакБольшеИлиРавно,
		//          +              -              *            /            %
		|ЗнакСложения, ЗнакВычитания, ЗнакУмножения, ЗнакДеления, ЗнакОстатка,
		//                (                    )                      [                       ]
		|ЛеваяКруглаяСкобка, ПраваяКруглаяСкобка, ЛеваяКвадратнаяСкобка, ПраваяКвадратнаяСкобка,
		//         ?        ,      .          :              ;
		|ЗнакВопроса, Запятая, Точка, Двоеточие, ТочкаСЗапятой,

		// ИнструкцииПрепроцессора
		|_Если, _ИначеЕсли, _Иначе, _КонецЕсли, _Область, _КонецОбласти,
		|_Вставка, _КонецВставки, _Удаление, _КонецУдаления, _Использовать,

		// Другие

		//                  //      ~          &          &
		|ПустаяСтрока, Комментарий, Метка, Аннотация, Директива, НачалоТекста, КонецТекста,";
	
	Результат = Новый Структура;
	
	// Добавляем ключевые слова
	Для Каждого КлючЗначение Из КлючевыеСлова Цикл
		Результат.Вставить(КлючЗначение.Ключ, КлючЗначение.Ключ);
	КонецЦикла;
	
	// Разбиваем строку на элементы по запятой и добавляем дополнительные токены
	МассивЭлементов = СтрРазделить(ДополнительныеТокены, ",", Ложь);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		ОчищенныйЭлемент = СокрЛП(Элемент);
		
		// Добавляем токен в структуру
		Результат.Вставить(ОчищенныйЭлемент, ОчищенныйЭлемент);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает текстовое представление логической строки
//
// Параметры:
//  БлокСтроки - Структура - блок логической строки с индексами токенов
//
// Возвращаемое значение:
//  Строка - текстовое представление логической строки
//
Функция ТекстЛогическойСтроки(БлокСтроки)
	МассивТекста = Новый Массив;
	ТекущийОтступСтроки = 1;
	ВложенностьСкобок = 0;
	НомерСтроки = 1;
	ПредыдущаяСтрока = 0;
	
	Для Индекс = БлокСтроки.НачИндекс По БлокСтроки.КонИндекс Цикл
		Токен = ТаблицаТокенов[Индекс];
		ТекстТекущегоТокена = ТекстТокена(Индекс);
		
		// Проверяем переход на новую строку
		Если ПредыдущаяСтрока > 0 И Токен.НомерСтроки > ПредыдущаяСтрока Тогда
			НомерСтроки = НомерСтроки + 1;
			МассивТекста.Добавить(Символы.ПС);
			// Добавляем отступ
			Для Счетчик = 1 По ТекущийОтступСтроки Цикл
				МассивТекста.Добавить(БазовыйОтступ);
			КонецЦикла;
		КонецЕсли;
		
		// Обработка особых случаев форматирования
		Если Токен.Токен = "ЛеваяКруглаяСкобка" Тогда
			МассивТекста.Добавить(ТекстТекущегоТокена);
			
			ВложенностьСкобок = ВложенностьСкобок + 1;
			Если ВложенностьСкобок > 1 ИЛИ НомерСтроки > 1 Тогда
				ТекущийОтступСтроки = ТекущийОтступСтроки + 1;
			КонецЕсли;
		ИначеЕсли Токен.Токен = "ПраваяКруглаяСкобка" Тогда
			ТекущийОтступСтроки = Макс(1, ТекущийОтступСтроки - 1);
			ВложенностьСкобок = ВложенностьСкобок - 1;

			МассивТекста.Добавить(ТекстТекущегоТокена);
		ИначеЕсли Токен.Токен = "ЗнакРавно" 
			ИЛИ Токен.Токен = "ЗнакНеРавно" 
			ИЛИ Токен.Токен = "ЗнакМеньше" 
			ИЛИ Токен.Токен = "ЗнакБольше" 
			ИЛИ Токен.Токен = "ЗнакМеньшеИлиРавно" 
			ИЛИ Токен.Токен = "ЗнакБольшеИлиРавно" 
			ИЛИ Токен.Токен = "ЗнакСложения" 
			ИЛИ Токен.Токен = "ЗнакВычитания" 
			ИЛИ Токен.Токен = "ЗнакУмножения" 
			ИЛИ Токен.Токен = "ЗнакДеления" 
			ИЛИ Токен.Токен = "ЗнакОстатка" 
			ИЛИ Токен.Токен = "И" 
			ИЛИ Токен.Токен = "Или" 
			ИЛИ Токен.Токен = "Не" 
		Тогда
			МассивТекста.Добавить(" " + ТекстТекущегоТокена + " ");
		
		ИначеЕсли Токен.Токен = "Запятая" 
			ИЛИ Токен.Токен = "Перем" 
			ИЛИ Токен.Токен = "ДобавитьОбработчик" 
			ИЛИ Токен.Токен = "УдалитьОбработчик" 
			ИЛИ Токен.Токен = "Новый" 
			ИЛИ Токен.Токен = "Выполнить" 
			ИЛИ Токен.Токен = "Перейти" 
			ИЛИ Токен.Токен = "Ждать" 
			ИЛИ Токен.Токен = "Возврат" 
		Тогда
			МассивТекста.Добавить(ТекстТекущегоТокена + " ");
		Иначе
			МассивТекста.Добавить(ТекстТекущегоТокена);
		КонецЕсли;
		
		ПредыдущаяСтрока = Токен.НомерСтроки;
	КонецЦикла;
	
	ТекстРезультат = СтрСоединить(МассивТекста);
	
	// Убираем двойные пробелы
	ТекстРезультат = СтрЗаменить(ТекстРезультат, "  ", " ");
	
	Возврат ТекстРезультат;
КонецФункции

// Процедура инициализации модуля
//
Процедура Инициализация()
	СимволыТокенов = Новый Соответствие;
	СимволыТокенов.Вставить("ЗнакРавно", "=");
	СимволыТокенов.Вставить("ЗнакНеРавно", "<>");
	СимволыТокенов.Вставить("ЗнакМеньше", "<");
	СимволыТокенов.Вставить("ЗнакБольше", ">");
	СимволыТокенов.Вставить("ЗнакМеньшеИлиРавно", "<=");
	СимволыТокенов.Вставить("ЗнакБольшеИлиРавно", ">=");
	СимволыТокенов.Вставить("ЗнакСложения", "+");
	СимволыТокенов.Вставить("ЗнакВычитания", "-");
	СимволыТокенов.Вставить("ЗнакУмножения", "*");
	СимволыТокенов.Вставить("ЗнакДеления", "/");
	СимволыТокенов.Вставить("ЗнакОстатка", "%");
	СимволыТокенов.Вставить("ЛеваяКруглаяСкобка", "(");
	СимволыТокенов.Вставить("ПраваяКруглаяСкобка", ")");
	СимволыТокенов.Вставить("ЛеваяКвадратнаяСкобка", "[");
	СимволыТокенов.Вставить("ПраваяКвадратнаяСкобка", "]");
	СимволыТокенов.Вставить("ЗнакВопроса", "?");
	СимволыТокенов.Вставить("Запятая", ",");
	СимволыТокенов.Вставить("Точка", ".");
	СимволыТокенов.Вставить("Двоеточие", ":");
	СимволыТокенов.Вставить("ТочкаСЗапятой", ";");

	КлючевыеСлова = КлючевыеСлова();
	Токены = Токены(КлючевыеСлова);
КонецПроцедуры

