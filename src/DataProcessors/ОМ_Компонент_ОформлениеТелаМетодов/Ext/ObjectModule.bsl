// Репозиторий проекта: 
// https://github.com/vladimir-kharin/1c_formatter
// 
// Харин Владимир (С) 2025. https://vharin.ru
// Telegram - https://t.me/vladimir_kharin

// Модуль оформления тела методов

// Глобальные переменные
Перем АнглСинтаксис;      // Флаг использования английского синтаксиса
Перем ТекущийОтступ;      // Текущий уровень отступа
Перем МассивЭлементовТекста; // Массив для формирования результата
Перем ТаблицаТокенов;     // Таблица токенов из парсера
Перем БазовыйОтступ;      // Строка отступа (табуляция)
Перем КлючевыеСлова;      // Таблица соответствия рус/англ ключевых слов
Перем Токены;             // Структура всех токенов
Перем ТокеныМеткаИлиПрепроцессор; // Структура токенов метки и препроцессора
Перем ИсходныйТекст;      // Исходный текст
Перем СимволыТокенов;     // Соответствие символов токенов
Перем НачатаНоваяСтрока;

// Основной метод оформления текста
//
// Параметры:
//  Текст - Строка - исходный текст для форматирования
//  _АнглСинтаксис - Булево - использовать английский синтаксис (по умолчанию Ложь)
//
// Возвращаемое значение:
//  Строка - отформатированный текст
//
Функция Оформить(Текст, _АнглСинтаксис = Ложь) Экспорт
	Инициализация();

	ИсходныйТекст = Текст;
	АнглСинтаксис = _АнглСинтаксис;
	ТекущийОтступ = 0;
	МассивЭлементовТекста = Новый Массив;
	БазовыйОтступ = Символы.Таб;
	НачатаНоваяСтрока = Истина;
	
	// Получение токенов и парсинг
	Парсер = Обработки.ОМ_Парсер_ПарсерВстроенногоЯзыка.Создать();
	ТаблицаТокенов = Парсер.Токенизировать(Текст);
	
	// Получение дерева блоков
	ПарсерДляОформления = Обработки.ОМ_Парсер_ПарсерВстроенногоЯзыкаБазовыеБоки.Создать();
	БлокКода = ПарсерДляОформления.Разобрать(ТаблицаТокенов);
	
	// Форматирование
	ОформитьБлокКода(БлокКода);
	
	// Объединение результата
    ТекстРезультат = СтрСоединить(МассивЭлементовТекста);
	
	Возврат ТекстРезультат;
КонецФункции

//////////////////////////////////////////////////////////////////////////////
// Базовые методы вывода

// Добавляет текст к результату
//
// Параметры:
//  Текст - Строка - текст для добавления
//
Процедура ВывестиТекст(Текст)
	Если НачатаНоваяСтрока Тогда
		ВывестиОтступ();
		НачатаНоваяСтрока = Ложь;
	КонецЕсли;

	ДобавитьВМассивТекста(МассивЭлементовТекста, Текст);
КонецПроцедуры

// Добавляет текст в массив с контролем двойных пробелов
//
// Параметры:
//  Массив - Массив - массив для добавления элемента
//  Текст - Строка - текст для добавления
//
Процедура ДобавитьВМассивТекста(Массив, Текст)
	// Если текст пустой, ничего не делаем
	Если Текст = "" Тогда
		Возврат;
	КонецЕсли;
	
	// Контроль двойных пробелов
	Если Текст = " " Тогда
		// Проверяем, не является ли последний элемент пробелом
		Если Массив.Количество() > 0 Тогда
			ПоследнийЭлемент = Массив[Массив.ВГраница()];
			Если ПоследнийЭлемент = " " 
				ИЛИ ПоследнийЭлемент = БазовыйОтступ
				ИЛИ ПоследнийЭлемент = Символы.ПС 
			Тогда
				Возврат;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// Добавляем текст в массив
	Массив.Добавить(Текст);
КонецПроцедуры

// Выводит многострочный текст с отступами
//
// Параметры:
//  Текст - Строка - текст для вывода
//
Процедура ВывестиМногострочныйТекст(Текст)
	КоличествоСтрок = СтрЧислоСтрок(Текст);
	
	Для Счетчик = 1 По КоличествоСтрок Цикл
		Строка = СтрПолучитьСтроку(Текст, Счетчик);
		ВывестиТекст(Строка);
		Если Счетчик < КоличествоСтрок Тогда
			НачатьНовуюСтроку();
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Выводит текущий отступ
//
Процедура ВывестиОтступ()
	Для Счетчик = 1 По ТекущийОтступ Цикл
		МассивЭлементовТекста.Добавить(БазовыйОтступ);
	КонецЦикла;
КонецПроцедуры

// Добавляет перевод строки
//
Процедура ВывестиПереводСтроки()
	МассивЭлементовТекста.Добавить(Символы.ПС);
КонецПроцедуры

// Добавляет перевод строки и отступ
//
Процедура НачатьНовуюСтроку()
	ВывестиПереводСтроки();
	НачатаНоваяСтрока = Истина;
КонецПроцедуры

// Выводит ключевое слово с учетом языка
//
// Параметры:
//  КлючевоеСлово - Строка - ключевое слово для вывода
//
Процедура ВывестиКлючевоеСлово(КлючевоеСлово)
	ВывестиТекст(ТекстКлючевогоСлова(КлючевоеСлово));
КонецПроцедуры

// Возвращает содержимое токена по индексу из исходной строки
//
// Параметры:
//  Индекс - Число - индекс токена в таблице токенов
//
// Возвращаемое значение:
//  Строка - часть исходной строки, соответствующая токену
//
Функция СодержимоеТокена(Индекс)
	Токен = ТаблицаТокенов[Индекс];
	Возврат Сред(ИсходныйТекст, Токен.Позиция, Токен.Длина);
КонецФункции


// Увеличивает текущий отступ
//
Процедура УвеличитьОтступ()
	ТекущийОтступ = ТекущийОтступ + 1;
КонецПроцедуры

// Уменьшает текущий отступ
//
Процедура УменьшитьОтступ()
	ТекущийОтступ = Макс(0, ТекущийОтступ - 1);
КонецПроцедуры

// Получает текст ключевого слова с учетом языка
//
// Параметры:
//  КлючевоеСлово - Строка - ключевое слово
//
// Возвращаемое значение:
//  Строка - текст ключевого слова на нужном языке
//
Функция ТекстКлючевогоСлова(КлючевоеСлово)
	Если Не КлючевыеСлова.Свойство(КлючевоеСлово) Тогда
		Возврат КлючевоеСлово;
	КонецЕсли;
	
	ТекстЛокализации = КлючевыеСлова[КлючевоеСлово];
	
	Если АнглСинтаксис Тогда
		Возврат НСтр(ТекстЛокализации, "en");
	Иначе
		Возврат НСтр(ТекстЛокализации, "ru");
	КонецЕсли;
КонецФункции

// Получает текстовое представление токена
//
// Параметры:
//  Индекс - Число - индекс токена в таблице
//
// Возвращаемое значение:
//  Строка - текстовое представление токена
//
Функция ТекстТокена(Индекс)
	Токен = ТаблицаТокенов[Индекс].Токен;

	// Обработка ключевых слов
	Если КлючевыеСлова.Свойство(Токен) Тогда
		Возврат ТекстКлючевогоСлова(Токен);
	КонецЕсли;
	
	// Обработка токенов препроцессора (начинаются с "_")
	Если СтрНачинаетсяС(Токен, "_") Тогда
		ТокенБезПрефикса = Сред(Токен, 2);
		Локализация = ?(АнглСинтаксис, "en", "ru");
		Если ТокенБезПрефикса = "Если" Тогда
			Возврат "#" + НСтр("ru='Если';en='If'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "ИначеЕсли" Тогда
			Возврат "#" + НСтр("ru='ИначеЕсли';en='ElsIf'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "Иначе" Тогда
			Возврат "#" + НСтр("ru='Иначе';en='Else'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "КонецЕсли" Тогда
			Возврат "#" + НСтр("ru='КонецЕсли';en='EndIf'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "Область" Тогда
			Возврат "#" + НСтр("ru='Область';en='Region'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "КонецОбласти" Тогда
			Возврат "#" + НСтр("ru='КонецОбласти';en='EndRegion'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "Вставка" Тогда
			Возврат "#" + НСтр("ru='Вставка';en='Insert'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "КонецВставки" Тогда
			Возврат "#" + НСтр("ru='КонецВставки';en='EndInsert'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "Удаление" Тогда
			Возврат "#" + НСтр("ru='Удаление';en='Delete'", Локализация);
		ИначеЕсли ТокенБезПрефикса = "КонецУдаления" Тогда
			Возврат "#" + НСтр("ru='КонецУдаления';en='EndDelete'", Локализация);
		Иначе
			ВызватьИсключение СтрШаблон("Неизвестный токен препроцессора: %1", Токен);
		КонецЕсли;
	КонецЕсли;
	
	// Обработка литералов и специальных токенов
	Если Токен = "Идентификатор" 
		ИЛИ Токен = "Число" 
		ИЛИ Токен = "Строка" 
		ИЛИ Токен = "ДатаВремя" 
		ИЛИ Токен = "ОкончаниеСтроки" 
		ИЛИ Токен = "Метка" 
	Тогда
		Возврат СодержимоеТокена(Индекс);
	ИначеЕсли Токен = "Комментарий" Тогда
		Возврат "//" + СодержимоеТокена(Индекс);
	ИначеЕсли Токен = "НачалоСтроки"
		ИЛИ Токен = "ПродолжениеСтроки" Тогда
		Содержимое = СодержимоеТокена(Индекс);
		Возврат Лев(Содержимое, СтрДлина(Содержимое) - 1);
	КонецЕсли;
	
	// Используем глобальную переменную СимволыТокенов
	// Проверяем, есть ли соответствие для токена
	Если СимволыТокенов[Токен] <> Неопределено Тогда
		Возврат СимволыТокенов[Токен];
	КонецЕсли;
	
	// Если это неизвестный токен, выбрасываем исключение
	ВызватьИсключение СтрШаблон("Неизвестный токен: %1", Токен);
КонецФункции

//////////////////////////////////////////////////////////////////////////////
// Методы форматирования блоков

// Форматирует блок кода (рекурсивный обход всех элементов)
//
// Параметры:
//  БлокКода - Структура - блок кода для форматирования
//
Процедура ОформитьБлокКода(БлокКода)
	Если БлокКода = Неопределено 
		ИЛИ БлокКода.Элементы = Неопределено 
		ИЛИ БлокКода.Элементы.Количество() = 0
	Тогда
		Возврат;
	КонецЕсли;
	
	НачИндекс = 0;
	КонИндекс = БлокКода.Элементы.ВГраница();
	
	// Пропускаем пустые строки в начале и в конце
	Пока БлокКода.Элементы[НачИндекс].ВидБлока = "ПустаяСтрока" Цикл
		НачИндекс = НачИндекс + 1;
	КонецЦикла;
	Пока КонИндекс >= НачИндекс 
		И БлокКода.Элементы[КонИндекс].ВидБлока = "ПустаяСтрока" 
	Цикл
		КонИндекс = КонИндекс - 1;
	КонецЦикла;
	
	Для Инд = НачИндекс По КонИндекс Цикл
		Блок = БлокКода.Элементы[Инд];
		ОформитьБлок(Блок);
	КонецЦикла;
КонецПроцедуры

// Определяет тип блока и вызывает соответствующий метод форматирования
//
// Параметры:
//  Блок - Структура - блок для форматирования
//
Процедура ОформитьБлок(Блок)
	Если Блок = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ВидБлока = Блок.ВидБлока;
	
	Если ВидБлока = "БлокКода" Тогда
		ОформитьБлокКода(Блок);
	ИначеЕсли ВидБлока = "ЛогическаяСтрока" Тогда
		ОформитьБлокЛогическойСтроки(Блок);
	ИначеЕсли ВидБлока = "Комментарий" Тогда
		ОформитьБлокКомментария(Блок);
	ИначеЕсли ВидБлока = "ПустаяСтрока" Тогда
		ОформитьБлокПустойСтроки(Блок);
	ИначеЕсли ВидБлока = "Если" Тогда
		ОформитьБлокЕсли(Блок);
	ИначеЕсли ВидБлока = "ИначеЕсли" Тогда
		ОформитьБлокИначеЕсли(Блок);
	ИначеЕсли ВидБлока = "Иначе" Тогда
		ОформитьБлокИначе(Блок);
	ИначеЕсли ВидБлока = "Пока" Тогда
		ОформитьБлокПока(Блок);
	ИначеЕсли ВидБлока = "Для" Тогда
		ОформитьБлокДля(Блок);
	ИначеЕсли ВидБлока = "ДляКаждого" Тогда
		ОформитьБлокДляКаждого(Блок);
	ИначеЕсли ВидБлока = "Попытка" Тогда
		ОформитьБлокПопытка(Блок);
	КонецЕсли;
КонецПроцедуры

// Проверяет наличие переносов строк в массиве элементов текста
//
// Параметры:
//  МассивТекста - Массив - массив элементов текста
//
// Возвращаемое значение:
//  Булево - Истина, если в массиве есть хотя бы один перенос строки
//
Функция ЕстьПереносыСтрокВМассиве(МассивТекста)
	Для Каждого Элемент Из МассивТекста Цикл
		Если Элемент = Символы.ПС Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

// Выводит элементы массива текста в результат
//
// Параметры:
//  МассивТекста - Массив - массив элементов текста для вывода
//
Процедура ВывестиМассивТекста(МассивТекста)
	Для Каждого Элемент Из МассивТекста Цикл
		Если Элемент = Символы.ПС Тогда
			НачатьНовуюСтроку();
		Иначе
			ВывестиТекст(Элемент);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Форматирует логическую строку
//
// Параметры:
//  БлокСтроки - Структура - блок логической строки
//  ВыводитьОтступ - Булево - необходимо ли выводить отступ
//
Процедура ОформитьБлокЛогическойСтроки(БлокСтроки)
	МассивТекста = МассивЭлементовТекстаЛогическойСтроки(БлокСтроки);
	
	// Вывод элементов массива
	ВывестиМассивТекста(МассивТекста);
	
	Если ЛогическаяСтрокаЗаканчиваетсяКомментарием(БлокСтроки) Тогда
		НачатьНовуюСтроку();
	КонецЕсли;
	
	// После метки и строки препроцессора точку с запятой не ставим
	НачТокен = ТаблицаТокенов[БлокСтроки.НачИндекс].Токен;
	Если Не ТокеныМеткаИлиПрепроцессор.Свойство(НачТокен) Тогда
		ВывестиТекст(";");
		
		// Вывод комментария после точки с запятой, если он есть
		Если БлокСтроки.ИндексКомментария > -1 Тогда
			ВывестиТекст(" ");
			ВывестиКомментарий(БлокСтроки.ИндексКомментария);
		КонецЕсли;
	КонецЕсли;
	
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует блок комментариев
//
// Параметры:
//  БлокКомментария - Структура - блок комментария
//
Процедура ОформитьБлокКомментария(БлокКомментария)
	Для Индекс = БлокКомментария.НачИндекс По БлокКомментария.КонИндекс Цикл
		ВывестиКомментарий(Индекс);
		НачатьНовуюСтроку();
	КонецЦикла;
КонецПроцедуры

// Выводит комментарий по индексу токена
//
// Параметры:
//  Индекс - Число - индекс токена в таблице токенов
//
Процедура ВывестиКомментарий(Индекс)
	ВывестиТекст("//");
	Содержимое = СодержимоеТокена(Индекс);
	
	Если СтрДлина(Содержимое) > 0 Тогда
		ПервыйСимвол = Лев(Содержимое, 1);
		Если ПервыйСимвол <> " " И ПервыйСимвол <> Символы.Таб Тогда
			ВывестиТекст(" ");
		КонецЕсли;
	КонецЕсли;
	
	ВывестиТекст(Содержимое);
КонецПроцедуры


// Форматирует блок пустых строк
//
// Параметры:
//  БлокПустойСтроки - Структура - блок пустой строки
//
Процедура ОформитьБлокПустойСтроки(БлокПустойСтроки)
	НачатьНовуюСтроку();
КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////
// Методы форматирования управляющих конструкций

// Форматирует конструкцию Если-Тогда-ИначеЕсли-Иначе-КонецЕсли
//
// Параметры:
//  БлокЕсли - Структура - блок условия Если
//
Процедура ОформитьБлокЕсли(БлокЕсли)
	// Выводим "Если" и условие
	ВывестиКлючевоеСлово("Если");
	ВывестиТекст(" ");

	МассивУсловие = МассивЭлементовТекстаЛогическойСтроки(БлокЕсли.Условие);
	Если ЕстьПереносыСтрокВМассиве(МассивУсловие) ИЛИ ЛогическаяСтрокаЗаканчиваетсяКомментарием(БлокЕсли.Условие) Тогда
		ВывестиМассивТекста(МассивУсловие);
		НачатьНовуюСтроку();
	Иначе
		ВывестиМассивТекста(МассивУсловие);
		ВывестиТекст(" ");
	КонецЕсли;

	ВывестиКлючевоеСлово("Тогда");

	УвеличитьОтступ();
	НачатьНовуюСтроку();

	ОформитьБлокКода(БлокЕсли.Тело);

	УменьшитьОтступ();
	
	// Обрабатываем ветки ИначеЕсли и Иначе
	Если БлокЕсли.ВеткиИначе <> Неопределено Тогда
		Для Каждого Ветка Из БлокЕсли.ВеткиИначе Цикл
			ОформитьБлок(Ветка);
		КонецЦикла;
	КонецЕсли;
	
	// Выводим "КонецЕсли"
	ВывестиКлючевоеСлово("КонецЕсли");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию ИначеЕсли-Тогда
//
// Параметры:
//  БлокИначеЕсли - Структура - блок условия ИначеЕсли
//
Процедура ОформитьБлокИначеЕсли(БлокИначеЕсли)
	// Выводим "ИначеЕсли" и условие
	ВывестиКлючевоеСлово("ИначеЕсли");
	ВывестиТекст(" ");

	МассивУсловие = МассивЭлементовТекстаЛогическойСтроки(БлокИначеЕсли.Условие);
	Если ЕстьПереносыСтрокВМассиве(МассивУсловие) ИЛИ ЛогическаяСтрокаЗаканчиваетсяКомментарием(БлокИначеЕсли.Условие) Тогда
		ВывестиМассивТекста(МассивУсловие);
		НачатьНовуюСтроку();
	Иначе
		ВывестиМассивТекста(МассивУсловие);
		ВывестиТекст(" ");
	КонецЕсли;

	ВывестиКлючевоеСлово("Тогда");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	ОформитьБлокКода(БлокИначеЕсли.Тело);
	
	УменьшитьОтступ();
КонецПроцедуры

// Форматирует конструкцию Иначе
//
// Параметры:
//  БлокИначе - Структура - блок условия Иначе
//
Процедура ОформитьБлокИначе(БлокИначе)
	// Выводим "Иначе"
	ВывестиКлючевоеСлово("Иначе");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело
	ОформитьБлокКода(БлокИначе.Тело);
	
	УменьшитьОтступ();
КонецПроцедуры

// Форматирует конструкцию Пока-Цикл-КонецЦикла
//
// Параметры:
//  БлокПока - Структура - блок цикла Пока
//
Процедура ОформитьБлокПока(БлокПока)
	// Выводим "Пока" и условие
	ВывестиКлючевоеСлово("Пока");
	ВывестиТекст(" ");

	МассивУсловие = МассивЭлементовТекстаЛогическойСтроки(БлокПока.Условие);
	Если ЕстьПереносыСтрокВМассиве(МассивУсловие) ИЛИ ЛогическаяСтрокаЗаканчиваетсяКомментарием(БлокПока.Условие) Тогда
		ВывестиМассивТекста(МассивУсловие);
		НачатьНовуюСтроку();
	Иначе
		ВывестиМассивТекста(МассивУсловие);
		ВывестиТекст(" ");
	КонецЕсли;

	ВывестиКлючевоеСлово("Цикл");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело цикла
	ОформитьБлокКода(БлокПока.Тело);
	
	УменьшитьОтступ();
	
	// Выводим "КонецЦикла"
	ВывестиКлючевоеСлово("КонецЦикла");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Для-По-Цикл-КонецЦикла
//
// Параметры:
//  БлокДля - Структура - блок цикла Для
//
Процедура ОформитьБлокДля(БлокДля)
	// Выводим "Для" и инициализацию
	ВывестиКлючевоеСлово("Для");
	ВывестиТекст(" ");
	
	МассивИнициализация = МассивЭлементовТекстаЛогическойСтроки(БлокДля.Инициализация);
	Если ЕстьПереносыСтрокВМассиве(МассивИнициализация) ИЛИ ЛогическаяСтрокаЗаканчиваетсяКомментарием(БлокДля.Инициализация) Тогда
		ВывестиМассивТекста(МассивИнициализация);
		НачатьНовуюСтроку();
	Иначе
		ВывестиМассивТекста(МассивИнициализация);
		ВывестиТекст(" ");
	КонецЕсли;
	
	// Выводим "По" и конечное значение
	ВывестиКлючевоеСлово("По");
	ВывестиТекст(" ");
	
	МассивКонецСчетчика = МассивЭлементовТекстаЛогическойСтроки(БлокДля.КонецСчетчика);
	Если ЕстьПереносыСтрокВМассиве(МассивКонецСчетчика) ИЛИ ЛогическаяСтрокаЗаканчиваетсяКомментарием(БлокДля.КонецСчетчика) Тогда
		ВывестиМассивТекста(МассивКонецСчетчика);
		НачатьНовуюСтроку();
	Иначе
		ВывестиМассивТекста(МассивКонецСчетчика);
		ВывестиТекст(" ");
	КонецЕсли;
	
	ВывестиКлючевоеСлово("Цикл");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело цикла
	ОформитьБлокКода(БлокДля.Тело);
	
	УменьшитьОтступ();
	
	// Выводим "КонецЦикла"
	ВывестиКлючевоеСлово("КонецЦикла");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Для-Каждого-Из-Цикл-КонецЦикла
//
// Параметры:
//  БлокДляКаждого - Структура - блок цикла Для Каждого
//
Процедура ОформитьБлокДляКаждого(БлокДляКаждого)
	// Выводим "Для Каждого" и элемент
	ВывестиКлючевоеСлово("Для");
	ВывестиТекст(" ");
	ВывестиКлючевоеСлово("Каждого");
	ВывестиТекст(" ");
	
	МассивЭлемент = МассивЭлементовТекстаЛогическойСтроки(БлокДляКаждого.Элемент);
	Если ЕстьПереносыСтрокВМассиве(МассивЭлемент) ИЛИ ЛогическаяСтрокаЗаканчиваетсяКомментарием(БлокДляКаждого.Элемент) Тогда
		ВывестиМассивТекста(МассивЭлемент);
		НачатьНовуюСтроку();
	Иначе
		ВывестиМассивТекста(МассивЭлемент);
		ВывестиТекст(" ");
	КонецЕсли;
	
	// Выводим "Из" и коллекцию
	ВывестиКлючевоеСлово("Из");
	ВывестиТекст(" ");
	
	МассивКоллекция = МассивЭлементовТекстаЛогическойСтроки(БлокДляКаждого.Коллекция);
	Если ЕстьПереносыСтрокВМассиве(МассивКоллекция) ИЛИ ЛогическаяСтрокаЗаканчиваетсяКомментарием(БлокДляКаждого.Коллекция) Тогда
		ВывестиМассивТекста(МассивКоллекция);
		НачатьНовуюСтроку();
	Иначе
		ВывестиМассивТекста(МассивКоллекция);
		ВывестиТекст(" ");
	КонецЕсли;
	
	ВывестиКлючевоеСлово("Цикл");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело цикла
	ОформитьБлокКода(БлокДляКаждого.Тело);
	
	УменьшитьОтступ();
	
	// Выводим "КонецЦикла"
	ВывестиКлючевоеСлово("КонецЦикла");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Попытка-Исключение-КонецПопытки
//
// Параметры:
//  БлокПопытка - Структура - блок обработки исключений
//
Процедура ОформитьБлокПопытка(БлокПопытка)
	// Выводим "Попытка"
	ВывестиКлючевоеСлово("Попытка");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело попытки
	ОформитьБлокКода(БлокПопытка.ТелоПопытки);
	
	УменьшитьОтступ();
	
	// Выводим "Исключение"
	ВывестиКлючевоеСлово("Исключение");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело обработки исключения
	ОформитьБлокКода(БлокПопытка.ТелоИсключения);
	
	УменьшитьОтступ();
	
	// Выводим "КонецПопытки"
	ВывестиКлючевоеСлово("КонецПопытки");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////
// Служебные методы

// Проверяет нахождение токенов на одной строке
//
// Параметры:
//  Индекс1 - Число - индекс первого токена
//  Индекс2 - Число - индекс второго токена
//
// Возвращаемое значение:
//  Булево - Истина, если токены на одной строке
//
Функция ТокеныНаОднойСтроке(Индекс1, Индекс2)
	Если Индекс1 < 0 ИЛИ Индекс2 < 0 ИЛИ 
		Индекс1 >= ТаблицаТокенов.Количество() ИЛИ 
		Индекс2 >= ТаблицаТокенов.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТаблицаТокенов[Индекс1].НомерСтроки = ТаблицаТокенов[Индекс2].НомерСтроки;
КонецФункции

// Возвращает структуру с ключевыми словами и их переводами
//
// Возвращаемое значение:
//  Структура - ключевые слова с переводами
//
Функция КлючевыеСлова()
	СтрокаКлючевыхСлов = 
		"Если.If, Тогда.Then, ИначеЕсли.ElsIf, Иначе.Else, КонецЕсли.EndIf,
		|Для.For, Каждого.Each, Из.In, По.To, Пока.While, Цикл.Do, КонецЦикла.EndDo,
		|Процедура.Procedure, КонецПроцедуры.EndProcedure, Функция.Function, КонецФункции.EndFunction,
		|Перем.Var, Знач.Val, Возврат.Return, Продолжить.Continue, Прервать.Break,
		|И.And, Или.Or, Не.Not, ДобавитьОбработчик.AddHandler, УдалитьОбработчик.RemoveHandler,
		|Попытка.Try, Исключение.Except, ВызватьИсключение.Raise, КонецПопытки.EndTry,
		|Новый.New, Выполнить.Execute, Экспорт.Export, Перейти.Goto,
		|Асинх.Async, Ждать.Await,
		|Истина.True, Ложь.False, Неопределено.Undefined, Null";
	
	Результат = Новый Структура;
	
	// Разбиваем строку на элементы по запятой
	МассивЭлементов = СтрРазделить(СтрокаКлючевыхСлов, ",", Ложь);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		ОчищенныйЭлемент = СокрЛП(Элемент);
		
		// Разбиваем на русское и английское слово
		МассивСлов = СтрРазделить(ОчищенныйЭлемент, ".", Ложь);
		
		Если МассивСлов.Количество() >= 2 Тогда
			РусскоеСлово = СокрЛП(МассивСлов[0]);
			АнглийскоеСлово = СокрЛП(МассивСлов[1]);
		Иначе
			// Если только один элемент, используем его и для русского и для английского
			РусскоеСлово = СокрЛП(МассивСлов[0]);
			АнглийскоеСлово = РусскоеСлово;
		КонецЕсли;
		
		// Формируем значение в требуемом формате
		ЗначениеСтруктуры = СтрШаблон("ru='%1';en='%2'", РусскоеСлово, АнглийскоеСлово);
		
		// Добавляем в структуру
		Результат.Вставить(РусскоеСлово, ЗначениеСтруктуры);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с токенами
//
// Параметры:
//  КлючевыеСлова - Структура - структура с ключевыми словами
//
// Возвращаемое значение:
//  Структура - токены языка
//
Функция Токены(КлючевыеСлова)
	ДополнительныеТокены = 
		"Идентификатор, Число, Строка, ДатаВремя,
		// Элементы строк
		|НачалоСтроки, ПродолжениеСтроки, ОкончаниеСтроки,

		// Операции

		//       =           <>           <           >
		|ЗнакРавно, ЗнакНеРавно, ЗнакМеньше, ЗнакБольше,
		//               <=                  >=
		|ЗнакМеньшеИлиРавно, ЗнакБольшеИлиРавно,
		//          +              -              *            /            %
		|ЗнакСложения, ЗнакВычитания, ЗнакУмножения, ЗнакДеления, ЗнакОстатка,
		//                (                    )                      [                       ]
		|ЛеваяКруглаяСкобка, ПраваяКруглаяСкобка, ЛеваяКвадратнаяСкобка, ПраваяКвадратнаяСкобка,
		//         ?        ,      .          :              ;
		|ЗнакВопроса, Запятая, Точка, Двоеточие, ТочкаСЗапятой,

		// ИнструкцииПрепроцессора
		|_Если, _ИначеЕсли, _Иначе, _КонецЕсли, _Область, _КонецОбласти,
		|_Вставка, _КонецВставки, _Удаление, _КонецУдаления, _Использовать,

		// Другие

		//                  //      ~          &          &
		|ПустаяСтрока, Комментарий, Метка, Аннотация, Директива, НачалоТекста, КонецТекста,";
	
	Результат = Новый Структура;
	
	// Добавляем ключевые слова
	Для Каждого КлючЗначение Из КлючевыеСлова Цикл
		Результат.Вставить(КлючЗначение.Ключ, КлючЗначение.Ключ);
	КонецЦикла;
	
	// Разбиваем строку на элементы по запятой и добавляем дополнительные токены
	МассивЭлементов = СтрРазделить(ДополнительныеТокены, ",", Ложь);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		ОчищенныйЭлемент = СокрЛП(Элемент);
		
		// Добавляем токен в структуру
		Результат.Вставить(ОчищенныйЭлемент, ОчищенныйЭлемент);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Проверяет, заканчивается ли логическая строка комментарием
//
// Параметры:
//  БлокСтроки - Структура - блок логической строки
//
// Возвращаемое значение:
//  Булево - Истина, если последний токен в строке - комментарий
//
Функция ЛогическаяСтрокаЗаканчиваетсяКомментарием(БлокСтроки)
	// Проверяем все токены с конца блока
	Индекс = БлокСтроки.КонИндекс;
	Пока Индекс >= БлокСтроки.НачИндекс Цикл
		Токен = ТаблицаТокенов[Индекс];
		
		// Пропускаем токены конца строки и другие незначимые токены
		Если Токен.Токен = "ПустаяСтрока" Тогда
			Индекс = Индекс - 1;
			Продолжить;
		КонецЕсли;

		Возврат Токен.Токен = "Комментарий";
	КонецЦикла;

	Возврат Ложь;
КонецФункции

// Возвращает текстовое представление логической строки
//
// Параметры:
//  БлокСтроки - Структура - блок логической строки с индексами токенов
//
// Возвращаемое значение:
//  Строка - текстовое представление логической строки
//
Функция МассивЭлементовТекстаЛогическойСтроки(БлокСтроки)
	МассивТекста = Новый Массив;
	ТекущийОтступСтроки = 1;
	ВложенностьСкобок = 0;
	НомерСтроки = 1;
	ПредыдущаяСтрока = 0;
	
	Для Индекс = БлокСтроки.НачИндекс По БлокСтроки.КонИндекс Цикл
		Токен = ТаблицаТокенов[Индекс];
		ТокенСтр = Токен.Токен;
		
		Если ТокенСтр = "ПустаяСтрока" Тогда
			Продолжить;
		КонецЕсли;
		
		ТекстТекущегоТокена = ТекстТокена(Индекс);
		
		// Проверяем переход на новую строку
		Если ПредыдущаяСтрока > 0 
			И (Токен.НомерСтроки > ПредыдущаяСтрока
				ИЛИ ТокенСтр = "НачалоСтроки") 
		Тогда
			НомерСтроки = НомерСтроки + 1;
			МассивТекста.Добавить(Символы.ПС);
			// Добавляем отступ
			Для Счетчик = 1 По ТекущийОтступСтроки Цикл
				МассивТекста.Добавить(БазовыйОтступ);
			КонецЦикла;
		КонецЕсли;
		
		// Обработка особых случаев форматирования
		Если ТокенСтр = "ЛеваяКруглаяСкобка" Тогда
			МассивТекста.Добавить(ТекстТекущегоТокена);
			
			ВложенностьСкобок = ВложенностьСкобок + 1;
			Если ВложенностьСкобок > 1 ИЛИ НомерСтроки > 1 Тогда
				ТекущийОтступСтроки = ТекущийОтступСтроки + 1;
			КонецЕсли;
		ИначеЕсли ТокенСтр = "ПраваяКруглаяСкобка" Тогда
			ТекущийОтступСтроки = Макс(1, ТекущийОтступСтроки - 1);
			ВложенностьСкобок = ВложенностьСкобок - 1;

			МассивТекста.Добавить(ТекстТекущегоТокена);
		ИначеЕсли ТокенСтр = "ЗнакРавно" 
			ИЛИ ТокенСтр = "ЗнакНеРавно" 
			ИЛИ ТокенСтр = "ЗнакМеньше" 
			ИЛИ ТокенСтр = "ЗнакБольше" 
			ИЛИ ТокенСтр = "ЗнакМеньшеИлиРавно" 
			ИЛИ ТокенСтр = "ЗнакБольшеИлиРавно" 
			ИЛИ ТокенСтр = "ЗнакСложения" 
			ИЛИ ТокенСтр = "ЗнакВычитания" 
			ИЛИ ТокенСтр = "ЗнакУмножения" 
			ИЛИ ТокенСтр = "ЗнакДеления" 
			ИЛИ ТокенСтр = "ЗнакОстатка" 
			ИЛИ ТокенСтр = "И" 
			ИЛИ ТокенСтр = "Или" 
			ИЛИ ТокенСтр = "Не" 
		Тогда
			ДобавитьВМассивТекста(МассивТекста, " ");
			ДобавитьВМассивТекста(МассивТекста, ТекстТекущегоТокена);
			ДобавитьВМассивТекста(МассивТекста, " ");
		
		ИначеЕсли ТокенСтр = "Запятая" 
			ИЛИ ТокенСтр = "Перем" 
			ИЛИ ТокенСтр = "ДобавитьОбработчик" 
			ИЛИ ТокенСтр = "УдалитьОбработчик" 
			ИЛИ ТокенСтр = "Новый" 
			ИЛИ ТокенСтр = "Выполнить" 
			ИЛИ ТокенСтр = "Перейти" 
			ИЛИ ТокенСтр = "Ждать" 
			ИЛИ ТокенСтр = "_Если" // препроцессор
			ИЛИ ТокенСтр = "_ИначеЕсли"
			ИЛИ ТокенСтр = "_Область"
		Тогда
			ДобавитьВМассивТекста(МассивТекста, ТекстТекущегоТокена);
			ДобавитьВМассивТекста(МассивТекста, " ");
		ИначеЕсли ТокенСтр = "Возврат" ИЛИ ТокенСтр = "ВызватьИсключение" Тогда
			ДобавитьВМассивТекста(МассивТекста, ТекстТекущегоТокена);
			
			// Добавляем пробел только если текущий токен не последний в блоке
			Если Индекс < БлокСтроки.КонИндекс Тогда
				ДобавитьВМассивТекста(МассивТекста, " ");
			КонецЕсли;
		ИначеЕсли ТокенСтр = "Комментарий"
			ИЛИ ТокенСтр = "Тогда" // для случая в препроцессоре
		Тогда
			ДобавитьВМассивТекста(МассивТекста, " ");
			ДобавитьВМассивТекста(МассивТекста, ТекстТекущегоТокена);
		Иначе
			ДобавитьВМассивТекста(МассивТекста, ТекстТекущегоТокена);
		КонецЕсли;
		
		ПредыдущаяСтрока = Токен.НомерСтроки;
	КонецЦикла;
	
	Возврат МассивТекста;
КонецФункции

// Процедура инициализации модуля
//
Процедура Инициализация()
	СимволыТокенов = Новый Соответствие;
	СимволыТокенов.Вставить("ЗнакРавно", "=");
	СимволыТокенов.Вставить("ЗнакНеРавно", "<>");
	СимволыТокенов.Вставить("ЗнакМеньше", "<");
	СимволыТокенов.Вставить("ЗнакБольше", ">");
	СимволыТокенов.Вставить("ЗнакМеньшеИлиРавно", "<=");
	СимволыТокенов.Вставить("ЗнакБольшеИлиРавно", ">=");
	СимволыТокенов.Вставить("ЗнакСложения", "+");
	СимволыТокенов.Вставить("ЗнакВычитания", "-");
	СимволыТокенов.Вставить("ЗнакУмножения", "*");
	СимволыТокенов.Вставить("ЗнакДеления", "/");
	СимволыТокенов.Вставить("ЗнакОстатка", "%");
	СимволыТокенов.Вставить("ЛеваяКруглаяСкобка", "(");
	СимволыТокенов.Вставить("ПраваяКруглаяСкобка", ")");
	СимволыТокенов.Вставить("ЛеваяКвадратнаяСкобка", "[");
	СимволыТокенов.Вставить("ПраваяКвадратнаяСкобка", "]");
	СимволыТокенов.Вставить("ЗнакВопроса", "?");
	СимволыТокенов.Вставить("Запятая", ",");
	СимволыТокенов.Вставить("Точка", ".");
	СимволыТокенов.Вставить("Двоеточие", ":");
	СимволыТокенов.Вставить("ТочкаСЗапятой", ";");

	КлючевыеСлова = КлючевыеСлова();
	Токены = Токены(КлючевыеСлова);
	
	ТокеныМеткаИлиПрепроцессор = Новый Структура;
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены.Метка, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._Если, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._ИначеЕсли, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._Иначе, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._КонецЕсли, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._Область, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._КонецОбласти, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._Вставка, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._КонецВставки, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._Удаление, Истина);
	ТокеныМеткаИлиПрепроцессор.Вставить(Токены._КонецУдаления, Истина);
КонецПроцедуры

