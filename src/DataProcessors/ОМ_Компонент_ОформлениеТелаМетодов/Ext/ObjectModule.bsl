// Репозиторий проекта: 
// https://github.com/vladimir-kharin/1c_formatter
// 
// Харин Владимир (С) 2025. https://vharin.ru
// Telegram - https://t.me/vladimir_kharin

// Модуль оформления тела методов

// Глобальные переменные
Перем АнглСинтаксис;      // Флаг использования английского синтаксиса
Перем ТекущийОтступ;      // Текущий уровень отступа
Перем МассивЭлементовТекста; // Массив для формирования результата
Перем ТаблицаТокенов;     // Таблица токенов из парсера
Перем БазовыйОтступ;      // Строка отступа (табуляция)
Перем КлючевыеСлова;      // Таблица соответствия рус/англ ключевых слов
Перем Токены;             // Таблица токенов
Перем ИсходныйТекст;      // Исходный текст

// Основной метод оформления текста
//
// Параметры:
//  Текст - Строка - исходный текст для форматирования
//  _АнглСинтаксис - Булево - использовать английский синтаксис (по умолчанию Ложь)
//
// Возвращаемое значение:
//  Строка - отформатированный текст
//
Функция Оформить(Текст, _АнглСинтаксис = Ложь) Экспорт
	// Инициализация
	ИсходныйТекст = Текст;
	АнглСинтаксис = _АнглСинтаксис;
	ТекущийОтступ = 0;
	МассивЭлементовТекста = Новый Массив;
	БазовыйОтступ = Символы.Таб;
	
	// Получение токенов и парсинг
	Парсер = Обработки.ОМ_Парсер_ПарсерВстроенногоЯзыка.Создать();
	КлючевыеСлова = КлючевыеСлова();
	Токены = Токены(КлючевыеСлова);
	ТаблицаТокенов = Парсер.Токенизировать(Текст);
	
	// Получение дерева блоков
	ПарсерДляОформления = Обработки.ОМ_Парсер_ПарсерВстроенногоЯзыкаБазовыеБоки.Создать();
	БлокКода = ПарсерДляОформления.Разобрать(ТаблицаТокенов);
	
	// Форматирование
	ОформитьБлокКода(БлокКода);
	
	// Объединение результата
	Возврат СтрСоединить(МассивЭлементовТекста);
КонецФункции

//////////////////////////////////////////////////////////////////////////////
// Базовые методы вывода

// Добавляет текст к результату
//
// Параметры:
//  Текст - Строка - текст для добавления
//
Процедура ВывестиТекст(Текст)
	МассивЭлементовТекста.Добавить(Текст);
КонецПроцедуры

// Выводит многострочный текст с отступами
//
// Параметры:
//  Текст - Строка - текст для вывода
//
Процедура ВывестиМногострочныйТекст(Текст)
	КоличествоСтрок = СтрЧислоСтрок(Текст);
	
	Для Счетчик = 1 По КоличествоСтрок Цикл
		Строка = СтрПолучитьСтроку(Текст, Счетчик);
		ВывестиТекст(Строка);
		Если Счетчик < КоличествоСтрок Тогда
			ВывестиПереводСтрокиИОтступ();
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Выводит текущий отступ
//
Процедура ВывестиОтступ()
	Для Счетчик = 1 По ТекущийОтступ Цикл
		ВывестиТекст(БазовыйОтступ);
	КонецЦикла;
КонецПроцедуры

// Добавляет перевод строки
//
Процедура ВывестиПереводСтроки()
	ВывестиТекст(Символы.ПС);
КонецПроцедуры

// Добавляет перевод строки и отступ
//
Процедура НачатьНовуюСтроку()
	ВывестиПереводСтроки();
	ВывестиОтступ();
КонецПроцедуры

// Выводит ключевое слово с учетом языка
//
// Параметры:
//  КлючевоеСлово - Строка - ключевое слово для вывода
//
Процедура ВывестиКлючевоеСлово(КлючевоеСлово)
	ВывестиТекст(ПолучитьТекстКлючевогоСлова(КлючевоеСлово));
КонецПроцедуры

// Выводит токен по индексу из таблицы токенов
//
// Параметры:
//  Индекс - Число - индекс токена в таблице токенов
//
Процедура ВывестиТокенПоИндексу(Индекс)
	ИмяТокена = ТаблицаТокенов[Индекс].Токен;
		
	// Проверка, является ли токен ключевым словом
	Если КлючевыеСлова.Свойство(ИмяТокена) Тогда
		ВывестиКлючевоеСлово(ИмяТокена);
	Иначе
		ВывестиТекст(ИмяТокена);
	КонецЕсли;
КонецПроцедуры

// Выводит все токены из диапазона
//
// Параметры:
//  НачИндекс - Число - начальный индекс диапазона
//  КонИндекс - Число - конечный индекс диапазона
//
Процедура ВывестиТокеныПоДиапазону(НачИндекс, КонИндекс)
	Для Индекс = НачИндекс По КонИндекс Цикл
		ВывестиТокенПоИндексу(Индекс);
		
		// Добавляем пробел между токенами, если это не последний токен
		Если Индекс < КонИндекс Тогда
			ВывестиТекст(" ");
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Возвращает содержимое токена по индексу из исходной строки
//
// Параметры:
//  Индекс - Число - индекс токена в таблице токенов
//
// Возвращаемое значение:
//  Строка - часть исходной строки, соответствующая токену
//
Функция СодержимоеТокена(Индекс)
	Токен = ТаблицаТокенов[Индекс];
	Возврат Сред(ИсходныйТекст, Токен.Позиция, Токен.Длина);
КонецФункции


// Увеличивает текущий отступ
//
Процедура УвеличитьОтступ()
	ТекущийОтступ = ТекущийОтступ + 1;
КонецПроцедуры

// Уменьшает текущий отступ
//
Процедура УменьшитьОтступ()
	ТекущийОтступ = Макс(0, ТекущийОтступ - 1);
КонецПроцедуры

// Получает текст ключевого слова с учетом языка
//
// Параметры:
//  КлючевоеСлово - Строка - ключевое слово
//
// Возвращаемое значение:
//  Строка - текст ключевого слова на нужном языке
//
Функция ПолучитьТекстКлючевогоСлова(КлючевоеСлово)
	Если Не КлючевыеСлова.Свойство(КлючевоеСлово) Тогда
		Возврат КлючевоеСлово;
	КонецЕсли;
	
	ТекстЛокализации = КлючевыеСлова[КлючевоеСлово];
	
	Если АнглСинтаксис Тогда
		Возврат НСтр(ТекстЛокализации, "en");
	Иначе
		Возврат НСтр(ТекстЛокализации, "ru");
	КонецЕсли;
КонецФункции

//////////////////////////////////////////////////////////////////////////////
// Методы форматирования блоков

// Форматирует блок кода (рекурсивный обход всех элементов)
//
// Параметры:
//  БлокКода - Структура - блок кода для форматирования
//
Процедура ОформитьБлокКода(БлокКода)
	Если БлокКода = Неопределено ИЛИ БлокКода.Элементы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	БлокПредыдущий = Неопределено;
	
	Для Каждого Блок Из БлокКода.Элементы Цикл
		// Проверяем, нужно ли добавить пустую строку перед блоком
		Если БлокПредыдущий <> Неопределено И ТребуетсяПустаяСтрокаПеред(Блок, БлокПредыдущий) Тогда
			ВывестиПереводСтроки();
		КонецЕсли;// TODO: надо ли это условие и проверка?
		
		// Форматируем блок
		ОформитьБлок(Блок);
		
		БлокПредыдущий = Блок;
	КонецЦикла;
КонецПроцедуры

// Определяет тип блока и вызывает соответствующий метод форматирования
//
// Параметры:
//  Блок - Структура - блок для форматирования
//
Процедура ОформитьБлок(Блок)
	Если Блок = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ВидБлока = Блок.ВидБлока;
	
	Если ВидБлока = "БлокКода" Тогда
		ОформитьБлокКода(Блок);
	ИначеЕсли ВидБлока = "ЛогическаяСтрока" Тогда
		ОформитьБлокЛогическойСтроки(Блок);
	ИначеЕсли ВидБлока = "Комментарий" Тогда
		ОформитьБлокКомментария(Блок);
	ИначеЕсли ВидБлока = "ПустаяСтрока" Тогда
		ОформитьБлокПустойСтроки(Блок);
	ИначеЕсли ВидБлока = "Если" Тогда
		ОформитьБлокЕсли(Блок);
	ИначеЕсли ВидБлока = "ИначеЕсли" Тогда
		ОформитьБлокИначеЕсли(Блок);
	ИначеЕсли ВидБлока = "Иначе" Тогда
		ОформитьБлокИначе(Блок);
	ИначеЕсли ВидБлока = "Пока" Тогда
		ОформитьБлокПока(Блок);
	ИначеЕсли ВидБлока = "Для" Тогда
		ОформитьБлокДля(Блок);
	ИначеЕсли ВидБлока = "ДляКаждого" Тогда
		ОформитьБлокДляКаждого(Блок);
	ИначеЕсли ВидБлока = "Попытка" Тогда
		ОформитьБлокПопытка(Блок);
	КонецЕсли;
КонецПроцедуры

// Форматирует логическую строку
//
// Параметры:
//  БлокСтроки - Структура - блок логической строки
//  ВыводитьОтступ - Булево - необходимо ли выводить отступ
//
Процедура ОформитьБлокЛогическойСтроки(БлокСтроки)
	Текст = ТекстЛогическойСтроки(БлокСтроки);
	// TODO: Вывод точки с запятой (если ее нет), а также комментария (если есть).
	ВывестиМногострочныйТекст(Текст);
	ВывестиПереводСтроки();
КонецПроцедуры

// Форматирует блок комментариев
//
// Параметры:
//  БлокКомментария - Структура - блок комментария
//
Процедура ОформитьБлокКомментария(БлокКомментария)
	Для Индекс = БлокКомментария.НачИндекс По БлокКомментария.КонИндекс Цикл
		ВывестиКомментарий(Индекс);
		НачатьНовуюСтроку();
	КонецЦикла;
КонецПроцедуры

// Выводит комментарий по индексу токена
//
// Параметры:
//  Индекс - Число - индекс токена в таблице токенов
//
Процедура ВывестиКомментарий(Индекс)
	ВывестиТекст("//");
	Содержимое = СодержимоеТокена(Индекс);
	
	Если СтрДлина(Содержимое) > 0 Тогда
		ПервыйСимвол = Лев(Содержимое, 1);
		Если ПервыйСимвол <> " " И ПервыйСимвол <> Символы.Таб Тогда
			ВывестиТекст(" ");
		КонецЕсли;
	КонецЕсли;
	
	ВывестиТекст(Содержимое);
КонецПроцедуры


// Форматирует блок пустых строк
//
// Параметры:
//  БлокПустойСтроки - Структура - блок пустой строки
//
Процедура ОформитьБлокПустойСтроки(БлокПустойСтроки)
	// Выводим только одну пустую строку
	НачатьНовуюСтроку();
КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////
// Методы форматирования управляющих конструкций

// Форматирует конструкцию Если-Тогда-ИначеЕсли-Иначе-КонецЕсли
//
// Параметры:
//  БлокЕсли - Структура - блок условия Если
//
Процедура ОформитьБлокЕсли(БлокЕсли)
	// Выводим "Если" и условие
	ВывестиКлючевоеСлово("Если");
	ВывестиТекст(" ");

	ТекстУсловие = ТекстЛогическойСтроки(БлокЕсли.Условие);
	Если СтрЧислоСтрок(ТекстУсловие) > 1 Тогда
		УвеличитьОтступ();
		ВывестиМногострочныйТекст(ТекстУсловие);
		УменьшитьОтступ();
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстУсловие);
		ВывестиТекст(" ");
	КонецЕсли;

	ВывестиКлючевоеСлово("Тогда");

	УвеличитьОтступ();
	НачатьНовуюСтроку();

	ОформитьБлокКода(БлокЕсли.Тело);

	УменьшитьОтступ();
	НачатьНовуюСтроку();
	
	// Обрабатываем ветки ИначеЕсли и Иначе
	Если БлокЕсли.ВеткиИначе <> Неопределено Тогда
		Для Каждого Ветка Из БлокЕсли.ВеткиИначе Цикл
			ОформитьБлок(Ветка);
		КонецЦикла;
	КонецЕсли;
	
	// Выводим "КонецЕсли"
	ВывестиКлючевоеСлово("КонецЕсли");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию ИначеЕсли-Тогда
//
// Параметры:
//  БлокИначеЕсли - Структура - блок условия ИначеЕсли
//
Процедура ОформитьБлокИначеЕсли(БлокИначеЕсли)
	// Выводим "ИначеЕсли" и условие
	ВывестиКлючевоеСлово("ИначеЕсли");
	ВывестиТекст(" ");

	ТекстУсловие = ТекстЛогическойСтроки(БлокИначеЕсли.Условие);
	Если СтрЧислоСтрок(ТекстУсловие) > 1 Тогда
		УвеличитьОтступ();
		ВывестиМногострочныйТекст(ТекстУсловие);
		УменьшитьОтступ();
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстУсловие);
		ВывестиТекст(" ");
	КонецЕсли;

	ВывестиКлючевоеСлово("Тогда");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	ОформитьБлокКода(БлокИначеЕсли.Тело);
	
	УменьшитьОтступ();
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Иначе
//
// Параметры:
//  БлокИначе - Структура - блок условия Иначе
//
Процедура ОформитьБлокИначе(БлокИначе)
	// Выводим "Иначе"
	ВывестиКлючевоеСлово("Иначе");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело
	ОформитьБлокКода(БлокИначе.Тело);
	
	УменьшитьОтступ();
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Пока-Цикл-КонецЦикла
//
// Параметры:
//  БлокПока - Структура - блок цикла Пока
//
Процедура ОформитьБлокПока(БлокПока)
	// Выводим "Пока" и условие
	ВывестиКлючевоеСлово("Пока");
	ВывестиТекст(" ");

	ТекстУсловие = ТекстЛогическойСтроки(БлокПока.Условие);
	Если СтрЧислоСтрок(ТекстУсловие) > 1 Тогда
		УвеличитьОтступ();
		ВывестиМногострочныйТекст(ТекстУсловие);
		УменьшитьОтступ();
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстУсловие);
		ВывестиТекст(" ");
	КонецЕсли;

	ВывестиКлючевоеСлово("Цикл");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело цикла
	ОформитьБлокКода(БлокПока.Тело);
	
	УменьшитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим "КонецЦикла"
	ВывестиКлючевоеСлово("КонецЦикла");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Для-По-Цикл-КонецЦикла
//
// Параметры:
//  БлокДля - Структура - блок цикла Для
//
Процедура ОформитьБлокДля(БлокДля)
	// Выводим "Для" и инициализацию
	ВывестиКлючевоеСлово("Для");
	ВывестиТекст(" ");
	
	ТекстИнициализация = ТекстЛогическойСтроки(БлокДля.Инициализация);
	Если СтрЧислоСтрок(ТекстИнициализация) > 1 Тогда
		УвеличитьОтступ();
		ВывестиМногострочныйТекст(ТекстИнициализация);
		УменьшитьОтступ();
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстИнициализация);
		ВывестиТекст(" ");
	КонецЕсли;
	
	// Выводим "По" и конечное значение
	ВывестиКлючевоеСлово("По");
	ВывестиТекст(" ");
	
	ТекстКонецСчетчика = ТекстЛогическойСтроки(БлокДля.КонецСчетчика);
	Если СтрЧислоСтрок(ТекстКонецСчетчика) > 1 Тогда
		УвеличитьОтступ();
		ВывестиМногострочныйТекст(ТекстКонецСчетчика);
		УменьшитьОтступ();
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстКонецСчетчика);
		ВывестиТекст(" ");
	КонецЕсли;
	
	ВывестиКлючевоеСлово("Цикл");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело цикла
	ОформитьБлокКода(БлокДля.Тело);
	
	УменьшитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим "КонецЦикла"
	ВывестиКлючевоеСлово("КонецЦикла");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Для-Каждого-Из-Цикл-КонецЦикла
//
// Параметры:
//  БлокДляКаждого - Структура - блок цикла Для Каждого
//
Процедура ОформитьБлокДляКаждого(БлокДляКаждого)
	// Выводим "Для Каждого" и элемент
	ВывестиКлючевоеСлово("Для");
	ВывестиТекст(" ");
	ВывестиКлючевоеСлово("Каждого");
	ВывестиТекст(" ");
	
	ТекстЭлемент = ТекстЛогическойСтроки(БлокДляКаждого.Элемент);
	ВывестиТекст(ТекстЭлемент);
	ВывестиТекст(" ");
	
	// Выводим "Из" и коллекцию
	ВывестиКлючевоеСлово("Из");
	ВывестиТекст(" ");
	
	ТекстКоллекция = ТекстЛогическойСтроки(БлокДляКаждого.Коллекция);
	Если СтрЧислоСтрок(ТекстКоллекция) > 1 Тогда
		УвеличитьОтступ();
		ВывестиМногострочныйТекст(ТекстКоллекция);
		УменьшитьОтступ();
		НачатьНовуюСтроку();
	Иначе
		ВывестиТекст(ТекстКоллекция);
		ВывестиТекст(" ");
	КонецЕсли;
	
	ВывестиКлючевоеСлово("Цикл");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело цикла
	ОформитьБлокКода(БлокДляКаждого.Тело);
	
	УменьшитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим "КонецЦикла"
	ВывестиКлючевоеСлово("КонецЦикла");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

// Форматирует конструкцию Попытка-Исключение-КонецПопытки
//
// Параметры:
//  БлокПопытка - Структура - блок обработки исключений
//
Процедура ОформитьБлокПопытка(БлокПопытка)
	// Выводим "Попытка"
	ВывестиКлючевоеСлово("Попытка");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело попытки
	ОформитьБлокКода(БлокПопытка.ТелоПопытки);
	
	УменьшитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим "Исключение"
	ВывестиКлючевоеСлово("Исключение");
	
	УвеличитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим тело обработки исключения
	ОформитьБлокКода(БлокПопытка.ТелоИсключения);
	
	УменьшитьОтступ();
	НачатьНовуюСтроку();
	
	// Выводим "КонецПопытки"
	ВывестиКлючевоеСлово("КонецПопытки");
	ВывестиТекст(";");
	НачатьНовуюСтроку();
КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////
// Служебные методы

// Определяет необходимость дополнительных пустых строк
//
// Параметры:
//  БлокТекущий - Структура - текущий блок
//  БлокПредыдущий - Структура - предыдущий блок
//
// Возвращаемое значение:
//  Булево - Истина, если требуется пустая строка
//
Функция ТребуетсяПустаяСтрокаПеред(БлокТекущий, БлокПредыдущий)
	Если БлокТекущий = Неопределено ИЛИ БлокПредыдущий = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Пустая строка перед управляющими конструкциями
	Если БлокТекущий.ВидБлока = "Если" ИЛИ 
		БлокТекущий.ВидБлока = "Пока" ИЛИ 
		БлокТекущий.ВидБлока = "Для" ИЛИ 
		БлокТекущий.ВидБлока = "ДляКаждого" ИЛИ 
		БлокТекущий.ВидБлока = "Попытка" Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Другие правила можно добавить по аналогии
	
	Возврат Ложь;
КонецФункции

// Проверяет нахождение токенов на одной строке
//
// Параметры:
//  Индекс1 - Число - индекс первого токена
//  Индекс2 - Число - индекс второго токена
//
// Возвращаемое значение:
//  Булево - Истина, если токены на одной строке
//
Функция ТокеныНаОднойСтроке(Индекс1, Индекс2)
	Если Индекс1 < 0 ИЛИ Индекс2 < 0 ИЛИ 
		Индекс1 >= ТаблицаТокенов.Количество() ИЛИ 
		Индекс2 >= ТаблицаТокенов.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТаблицаТокенов[Индекс1].НомерСтроки = ТаблицаТокенов[Индекс2].НомерСтроки;
КонецФункции

// Возвращает структуру с ключевыми словами и их переводами
//
// Возвращаемое значение:
//  Структура - ключевые слова с переводами
//
Функция КлючевыеСлова()
	СтрокаКлючевыхСлов = 
		"Если.If, Тогда.Then, ИначеЕсли.ElsIf, Иначе.Else, КонецЕсли.EndIf,
		|Для.For, Каждого.Each, Из.In, По.To, Пока.While, Цикл.Do, КонецЦикла.EndDo,
		|Процедура.Procedure, КонецПроцедуры.EndProcedure, Функция.Function, КонецФункции.EndFunction,
		|Перем.Var, Знач.Val, Возврат.Return, Продолжить.Continue, Прервать.Break,
		|И.And, Или.Or, Не.Not, ДобавитьОбработчик.AddHandler, УдалитьОбработчик.RemoveHandler,
		|Попытка.Try, Исключение.Except, ВызватьИсключение.Raise, КонецПопытки.EndTry,
		|Новый.New, Выполнить.Execute, Экспорт.Export, Перейти.Goto,
		|Асинх.Async, Ждать.Await,
		|Истина.True, Ложь.False, Неопределено.Undefined, Null";
	
	Результат = Новый Структура;
	
	// Разбиваем строку на элементы по запятой
	МассивЭлементов = СтрРазделить(СтрокаКлючевыхСлов, ",", Ложь);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		ОчищенныйЭлемент = СокрЛП(Элемент);
		
		// Разбиваем на русское и английское слово
		МассивСлов = СтрРазделить(ОчищенныйЭлемент, ".", Ложь);
		
		Если МассивСлов.Количество() >= 2 Тогда
			РусскоеСлово = СокрЛП(МассивСлов[0]);
			АнглийскоеСлово = СокрЛП(МассивСлов[1]);
		Иначе
			// Если только один элемент, используем его и для русского и для английского
			РусскоеСлово = СокрЛП(МассивСлов[0]);
			АнглийскоеСлово = РусскоеСлово;
		КонецЕсли;
		
		// Формируем значение в требуемом формате
		ЗначениеСтруктуры = СтрШаблон("ru='%1';en='%2'", РусскоеСлово, АнглийскоеСлово);
		
		// Добавляем в структуру
		Результат.Вставить(РусскоеСлово, ЗначениеСтруктуры);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с токенами
//
// Параметры:
//  КлючевыеСлова - Структура - структура с ключевыми словами
//
// Возвращаемое значение:
//  Структура - токены языка
//
Функция Токены(КлючевыеСлова)
	ДополнительныеТокены = 
		"Идентификатор, Число, Строка, ДатаВремя,
		// Элементы строк
		|НачалоСтроки, ПродолжениеСтроки, ОкончаниеСтроки,

		// Операции

		//       =           <>           <           >
		|ЗнакРавно, ЗнакНеРавно, ЗнакМеньше, ЗнакБольше,
		//               <=                  >=
		|ЗнакМеньшеИлиРавно, ЗнакБольшеИлиРавно,
		//          +              -              *            /            %
		|ЗнакСложения, ЗнакВычитания, ЗнакУмножения, ЗнакДеления, ЗнакОстатка,
		//                (                    )                      [                       ]
		|ЛеваяКруглаяСкобка, ПраваяКруглаяСкобка, ЛеваяКвадратнаяСкобка, ПраваяКвадратнаяСкобка,
		//         ?        ,      .          :              ;
		|ЗнакВопроса, Запятая, Точка, Двоеточие, ТочкаСЗапятой,

		// ИнструкцииПрепроцессора
		|_Если, _ИначеЕсли, _Иначе, _КонецЕсли, _Область, _КонецОбласти,
		|_Вставка, _КонецВставки, _Удаление, _КонецУдаления, _Использовать,

		// Другие

		//                  //      ~          &          &
		|ПустаяСтрока, Комментарий, Метка, Аннотация, Директива, НачалоТекста, КонецТекста,";
	
	Результат = Новый Структура;
	
	// Добавляем ключевые слова
	Для Каждого КлючЗначение Из КлючевыеСлова Цикл
		Результат.Вставить(КлючЗначение.Ключ, КлючЗначение.Ключ);
	КонецЦикла;
	
	// Разбиваем строку на элементы по запятой и добавляем дополнительные токены
	МассивЭлементов = СтрРазделить(ДополнительныеТокены, ",", Ложь);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		ОчищенныйЭлемент = СокрЛП(Элемент);
		
		// Добавляем токен в структуру
		Результат.Вставить(ОчищенныйЭлемент, ОчищенныйЭлемент);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции
