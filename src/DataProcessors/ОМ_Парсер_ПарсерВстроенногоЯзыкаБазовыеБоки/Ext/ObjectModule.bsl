// Репозиторий проекта:
// https://github.com/vladimir-kharin/1c_formatter
// 
// Харин Владимир (С) 2025. https://vharin.ru
// Telegram - https://t.me/vladimir_kharin

// Парсер встроенного языка 1С (на базовые блоки)

#Область ОписаниеПеременных

Перем ТекущийИндекс; // Индекс текущего обрабатываемого токена

Перем ТаблицаТокенов; // Таблица токенов для обработки

Перем ВсегоТокенов; // Общее количество токенов

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Функция выполняет синтаксический разбор таблицы токенов в древовидную структуру базовых блоков
//
// Параметры:
//  Токены - ТаблицаЗначений - Входная таблица токенов со структурой:
//    * Индекс         - Число   - Порядковый номер токена (должен быть уникальным и последовательным)
//    * Токен          - Строка  - Тип токена (из перечисления Токены())
//    * НомерСтроки    - Число   - Номер строки в исходном коде
//    * НомерКолонки   - Число   - Позиция в строке
//    * Позиция        - Число   - Абсолютная позиция в тексте
//    * Длина          - Число   - Длина токена в символах
//  Таблицу токенов можно получить следующим образом:
//    // Получение токенов и парсинг
//    Парсер = Обработки.ОМ_Парсер_ПарсерВстроенногоЯзыка.Создать();
//    ТаблицаТокенов = Парсер.Токенизировать(Текст);
//  В коде не должно быть объявлений методов (разбор структуры модуля делается на другом уровне обработки)
//
// Возвращаемое значение:
//  Структура - Корневой блок кода вида:
//    {
//      ВидБлока: "БлокКода",
//      Элементы: Массив - Содержит вложенные блоки:
//        [
//          {ВидБлока: "ЛогическаяСтрока", НачИндекс: N, КонИндекс: M, ИндексКомментария: K},
//          {ВидБлока: "Комментарий", НачИндекс: N, КонИндекс: M},
//          {ВидБлока: "ПустаяСтрока", НачИндекс: N, КонИндекс: M},
//          {ВидБлока: "Если", Условие: Структура, Тело: Структура, ВеткиИначе: Массив},
//          {ВидБлока: "Пока", Условие: Структура, Тело: Структура},
//          {ВидБлока: "Для", Инициализация: Структура, КонецСчетчика: Структура, Тело: Структура},
//          {ВидБлока: "ДляКаждого", Элемент: Структура, Коллекция: Структура, Тело: Структура},
//          {ВидБлока: "Попытка", ТелоПопытки: Структура, ТелоИсключения: Структура}
//        ]
//    }
//
// Описание структур блоков:
// 1. Блок кода:
//    {
//      ВидБлока: "БлокКода",
//      Элементы: Массив - вложенные элементы любого типа
//    }
//
// 2. Логическая строка:
//    {
//      ВидБлока: "ЛогическаяСтрока",
//      НачИндекс: Число - индекс первого токена строки,
//      КонИндекс: Число - индекс последнего токена строки,
//      ИндексКомментария: Число - индекс комментария после точки с запятой (-1 если нет)
//    }
//
// 3. Условия:
//    Если {
//      ВидБлока: "Если",
//      Условие: Структура - блок логической строки между "Если" и "Тогда",
//      Тело: Структура - блок кода между "Тогда" и ветки Иначе,
//      ВеткиИначе: Массив - блоки ИначеЕсли/Иначе
//    }
//    ИначеЕсли {
//      ВидБлока: "ИначеЕсли",
//      Условие: Структура - блок между "ИначеЕсли" и "Тогда",
//      Тело: Структура - блок кода
//    }
//    Иначе {
//      ВидБлока: "Иначе",
//      Тело: Структура - блок кода
//    }
//
// 4. Циклы:
//    Пока {
//      ВидБлока: "Пока",
//      Условие: Структура - блок между "Пока" и "Цикл",
//      Тело: Структура - блок кода
//    }
//    Для {
//      ВидБлока: "Для",
//      Инициализация: Структура - блок между "Для" и "По",
//      КонецСчетчика: Структура - блок между "По" и "Цикл",
//      Тело: Структура - блок кода
//    }
//    ДляКаждого {
//      ВидБлока: "ДляКаждого",
//      Элемент: Структура - блок между "Для" и "Из",
//      Коллекция: Структура - блок между "Из" и "Цикл",
//      Тело: Структура - блок кода
//    }
//
// 5. Обработка исключений:
//    Попытка {
//      ВидБлока: "Попытка",
//      ТелоПопытки: Структура - блок между "Попытка" и "Исключение",
//      ТелоИсключения: Структура - блок между "Исключение" и "КонецПопытки"
//    }
//
// 6. Служебные блоки:
//    Комментарий {
//      ВидБлока: "Комментарий",
//      НачИндекс: Число - индекс первого токена,
//      КонИндекс: Число - индекс последнего токена
//    }
//    ПустаяСтрока {
//      ВидБлока: "Пу空地Строка",
//      НачИндекс: Число,
//      КонИндекс: Число
//    }
//
// Получение токенов и парсинг
//	Парсер = Обработки.ОМ_Парсер_ПарсерВстроенногоЯзыка.Создать();
//	ТаблицаТокенов = Парсер.Токенизировать(Текст);
//	
//	// Получение дерева блоков
//	ПарсерДляОформления = Обработки.ОМ_Парсер_ПарсерВстроенногоЯзыкаБазовыеБоки.Создать();
//	БлокКода = ПарсерДляОформления.Разобрать(ТаблицаТокенов);
//
// Особенности:
//  - Автоматически объединяет последовательные комментарии и пустые строки
//  - Обрабатывает вложенные конструкции любой глубины
//  - Сохраняет индексы токенов для последующего форматирования
//  - Учитывает комментарии после точки с запятой в логических строках
Функция Разобрать(Токены) Экспорт

	ТаблицаТокенов = Токены;
	ВсегоТокенов = ТаблицаТокенов.Количество();
	ТекущийИндекс = 1;
	
	Возврат РазобратьБлокКода(Новый Структура("КонецТекста"));

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция РазобратьБлокКода(СтруктураЗавершающиеТокены)

	Блок = СоздатьБлокКода();
	
	Пока ТекущийИндекс < ВсегоТокенов Цикл
		ПропуститьТочкуСЗапятой();
		
		ТекущийТокен = ТаблицаТокенов[ТекущийИндекс].Токен;
		
		// Проверяем на завершающий токен
		Если СтруктураЗавершающиеТокены <> Неопределено 
			И СтруктураЗавершающиеТокены.Свойство(ТекущийТокен) Тогда
			Возврат Блок;
		КонецЕсли;
		
		Если ТекущийТокен = "Комментарий" Тогда
			БлокКомментария = РазобратьКомментарий();
			Блок.Элементы.Добавить(БлокКомментария);
		ИначеЕсли ТекущийТокен = "ПустаяСтрока" Тогда
			БлокПустой = РазобратьПустыеСтроки();
			Блок.Элементы.Добавить(БлокПустой);
	    ИначеЕсли ТекущийТокен = "Если" Тогда
			БлокУсловия = РазобратьЕсли();
			Блок.Элементы.Добавить(БлокУсловия);
		ИначеЕсли ТекущийТокен = "Пока" Тогда
			БлокЦикла = РазобратьПока();
			Блок.Элементы.Добавить(БлокЦикла);
		ИначеЕсли ТекущийТокен = "Для" Тогда
			РезультатПоиска = ПолучитьСледующийЗначимыйТокен(ТекущийИндекс + 1);
			Если РезультатПоиска.Токен = "Каждого" Тогда
				БлокЦикла = РазобратьДляКаждого();
			Иначе
				БлокЦикла = РазобратьДля();
			КонецЕсли;
			Блок.Элементы.Добавить(БлокЦикла);
		ИначеЕсли ТекущийТокен = "Попытка" Тогда
			БлокПопытки = РазобратьПопытку();
			Блок.Элементы.Добавить(БлокПопытки);
	    Иначе
	    	ЛогическаяСтрока = РазобратьЛогическуюСтроку();
		    Блок.Элементы.Добавить(ЛогическаяСтрока);
	    КонецЕсли;
	КонецЦикла;
	
	Возврат Блок;

КонецФункции

// Процедура пропускает токен точки с запятой, если он следующий
Процедура ПропуститьТочкуСЗапятой()

	Пока ТекущийИндекс < ВсегоТокенов И ТаблицаТокенов[ТекущийИндекс].Токен = "ТочкаСЗапятой" Цикл
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;

КонецПроцедуры

// Функция получает следующий значимый токен, пропуская комментарии и пустые строки
// 
// Параметры:
//  НачальныйИндекс - Число - индекс, с которого начинается поиск
// 
// Возвращаемое значение:
// Структура - структура с информацией о найденном токене:
// Токен - Строка - найденный токен или пустая строка, если достигнут конец таблицы токенов
// Индекс - Число - индекс найденного токена или -1, если токен не найден
Функция ПолучитьСледующийЗначимыйТокен(НачальныйИндекс)

	Индекс = НачальныйИндекс;
	
	Пока Индекс < ВсегоТокенов Цикл
		ТекущийТокен = ТаблицаТокенов[Индекс].Токен;
		Если ТекущийТокен <> "Комментарий" И ТекущийТокен <> "ПустаяСтрока" Тогда
			Возврат Новый Структура("Токен, Индекс", ТекущийТокен, Индекс);
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат Новый Структура("Токен, Индекс", "", -1);

КонецФункции

// Функция получает предыдущий значимый токен, пропуская комментарии и пустые строки
// 
// Параметры:
//  НачальныйИндекс   - Число - индекс, с которого начинается поиск в обратном направлении
//  МинимальныйИндекс - Число - минимальный индекс, до которого производится поиск (по умолчанию 0)
// 
// Возвращаемое значение:
// Структура - структура с информацией о найденном токене:
// Токен - Строка - найденный токен или пустая строка, если достигнут начало таблицы токенов
// Индекс - Число - индекс найденного токена или -1, если токен не найден
Функция ПолучитьПредыдущийЗначимыйТокен(НачальныйИндекс, МинимальныйИндекс = 0)

	Индекс = НачальныйИндекс;
	
	Пока Индекс >= МинимальныйИндекс Цикл
		ТекущийТокен = ТаблицаТокенов[Индекс].Токен;
		Если ТекущийТокен <> "Комментарий" И ТекущийТокен <> "ПустаяСтрока" Тогда
			Возврат Новый Структура("Токен, Индекс", ТекущийТокен, Индекс);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
	Возврат Новый Структура("Токен, Индекс", "", -1);

КонецФункции

// Функция разбирает непрерывный блок комментариев
// 
// Возвращаемое значение:
// Структура - блок комментария
Функция РазобратьКомментарий()

	НачИндекс = ТекущийИндекс;
	
	// Ищем последовательные комментарии
	Пока ТекущийИндекс < ВсегоТокенов И ТаблицаТокенов[ТекущийИндекс].Токен = "Комментарий" Цикл
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	КонИндекс = ТекущийИндекс - 1;
	
	// Создаем блок комментария
	Возврат СоздатьБлокКомментария(НачИндекс, КонИндекс);

КонецФункции

// Функция разбирает непрерывный блок пустых строк
// 
// Возвращаемое значение:
// Структура - блок пустых строк
Функция РазобратьПустыеСтроки()

	НачИндекс = ТекущийИндекс;
	
	// Ищем последовательные пустые строки
	Пока ТекущийИндекс < ВсегоТокенов И ТаблицаТокенов[ТекущийИндекс].Токен = "ПустаяСтрока" Цикл
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	КонИндекс = ТекущийИндекс - 1;
	
	// Создаем блок пустых строк
	Возврат СоздатьБлокПустойСтроки(НачИндекс, КонИндекс);

КонецФункции

// Функция разбирает логическую строку
// 
// Возвращаемое значение:
// Структура - блок логической строки
Функция РазобратьЛогическуюСтроку()

	НачИндекс = ТекущийИндекс;
	ЭтоИнструкцияПрепроцессора = Ложь;
	
	// Проверяем, является ли токен инструкцией препроцессора
	ТекущийТокен = ТаблицаТокенов[ТекущийИндекс].Токен;
	ЭтоИнструкцияПрепроцессора = (Лев(ТекущийТокен, 1) = "_");
	
	ТекущийНомерСтроки = ТаблицаТокенов[ТекущийИндекс].НомерСтроки;
	
	// Список завершающих токенов
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("ТочкаСЗапятой", Истина);
	ЗавершающиеТокены.Вставить("Двоеточие", Истина);
	ЗавершающиеТокены.Вставить("ИначеЕсли", Истина);
	ЗавершающиеТокены.Вставить("Иначе", Истина);
	ЗавершающиеТокены.Вставить("КонецЕсли", Истина);
	ЗавершающиеТокены.Вставить("КонецЦикла", Истина);
	ЗавершающиеТокены.Вставить("КонецТекста", Истина);
	ЗавершающиеТокены.Вставить("Из", Истина);
	ЗавершающиеТокены.Вставить("По", Истина);
	ЗавершающиеТокены.Вставить("Цикл", Истина);
	ЗавершающиеТокены.Вставить("Тогда", Истина);
	
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Обрабатываем токены до завершающего или до конца строки для препроцессора
	Пока ТекущийИндекс < ВсегоТокенов Цикл
		ТекущийТокен = ТаблицаТокенов[ТекущийИндекс].Токен;
		
		// Проверка для инструкций препроцессора - завершаем при смене строки
		Если ЭтоИнструкцияПрепроцессора И ТаблицаТокенов[ТекущийИндекс].НомерСтроки <> ТекущийНомерСтроки Тогда
			Прервать;
		КонецЕсли;
		
		// Проверка на завершающие токены для обычных строк
		Если НЕ ЭтоИнструкцияПрепроцессора И ЗавершающиеТокены.Свойство(ТекущийТокен) Тогда
			Прервать;
		КонецЕсли;
		
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	// Стоп-токен двоеточие включаем в логическую строку, все остальное - нет
	Если ТекущийТокен = "Двоеточие" Тогда
		КонИндекс = ТекущийИндекс;
		ТекущийИндекс = ТекущийИндекс + 1;
	Иначе
		КонИндекс = ТекущийИндекс - 1;
	КонецЕсли;
	
	// Запоминаем, если текущий токен - точка с запятой
	БылаТочкаСЗапятой = (ТекущийТокен = "ТочкаСЗапятой");
	ИндексТочкиСЗапятой = ?(БылаТочкаСЗапятой, ТекущийИндекс, Неопределено);
	
	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Проверяем, есть ли комментарий сразу после точки с запятой
	ИндексКомментария = -1;
	Если БылаТочкаСЗапятой 
	    И ТекущийИндекс < ВсегоТокенов 
	    И ТаблицаТокенов[ТекущийИндекс].Токен = "Комментарий" 
	Тогда
		// Проверяем, что комментарий находится в той же строке
		КомментарийНомерСтроки = ТаблицаТокенов[ТекущийИндекс].НомерСтроки;
		ТочкаСЗапятойНомерСтроки = ТаблицаТокенов[ИндексТочкиСЗапятой].НомерСтроки;
		
		Если КомментарийНомерСтроки = ТочкаСЗапятойНомерСтроки Тогда
			// Сохраняем индекс комментария
			ИндексКомментария = ТекущийИндекс;
			// Переходим к следующему токену
			ТекущийИндекс = ТекущийИндекс + 1;
		КонецЕсли;
	КонецЕсли;
	
	// Создаем блок логической строки
	Возврат СоздатьБлокЛогическойСтроки(НачИндекс, КонИндекс, ИндексКомментария);

КонецФункции

// Функция разбирает конструкцию Если-Тогда-ИначеЕсли-Иначе-КонецЕсли
// 
// Возвращаемое значение:
// Структура - блок условия Если
Функция РазобратьЕсли()

	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Если"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем условие до токена "Тогда"
	Условие = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Тогда"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Тогда" Тогда
		ВызватьИсключение СтрШаблон(
	        "Ожидается токен 'Тогда' после условия, найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
	        ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Тогда"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело условия до веток "ИначеЕсли", "Иначе" или "КонецЕсли"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("ИначеЕсли", Истина);
	ЗавершающиеТокены.Вставить("Иначе", Истина);
	ЗавершающиеТокены.Вставить("КонецЕсли", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Обрабатываем ветки ИначеЕсли и Иначе
	ВеткиИначе = Новый Массив;
	
	Пока ТекущийИндекс < ВсегоТокенов Цикл
		ТекущийТокен = ТаблицаТокенов[ТекущийИндекс].Токен;
		
		Если ТекущийТокен = "ИначеЕсли" Тогда
			ВеткаИначеЕсли = РазобратьИначеЕсли();
			ВеткиИначе.Добавить(ВеткаИначеЕсли);
		ИначеЕсли ТекущийТокен = "Иначе" Тогда
			ВеткаИначе = РазобратьИначе();
			ВеткиИначе.Добавить(ВеткаИначе);
		ИначеЕсли ТекущийТокен = "КонецЕсли" Тогда
			// Пропускаем токен "КонецЕсли"
			ТекущийИндекс = ТекущийИндекс + 1;
			
			// Пропускаем точку с запятой
			ПропуститьТочкуСЗапятой();
			
			Прервать;
		Иначе
			ВызватьИсключение СтрШаблон(
				"Ожидается 'ИначеЕсли', 'Иначе' или 'КонецЕсли', найден '%1' (строка %2)",
				ТекущийТокен, 
				ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
		КонецЕсли;
	КонецЦикла;
	
	// Проверка на наличие КонецЕсли
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	 	КонецЕсли;
	
	// Создаем блок условия Если
	Возврат СоздатьБлокЕсли(Условие, Тело, ВеткиИначе);

КонецФункции

// Функция разбирает конструкцию ИначеЕсли-Тогда
// 
// Возвращаемое значение:
// Структура - блок условия ИначеЕсли
Функция РазобратьИначеЕсли()

	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "ИначеЕсли"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем условие до токена "Тогда"
	Условие = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Тогда"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Тогда" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Тогда' после условия, найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Тогда"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело условия до следующих веток или "КонецЕсли"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("ИначеЕсли", Истина);
	ЗавершающиеТокены.Вставить("Иначе", Истина);
	ЗавершающиеТокены.Вставить("КонецЕсли", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Создаем блок условия ИначеЕсли
	Возврат СоздатьБлокИначеЕсли(Условие, Тело);

КонецФункции

// Функция разбирает конструкцию Иначе
// 
// Возвращаемое значение:
// Структура - блок условия Иначе
Функция РазобратьИначе()

	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Иначе"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело условия до "КонецЕсли"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецЕсли", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Создаем блок условия Иначе
	Возврат СоздатьБлокИначе(Тело);

КонецФункции

// Функция разбирает конструкцию Пока-Цикл-КонецЦикла
// 
// Возвращаемое значение:
// Структура - блок цикла Пока
Функция РазобратьПока()

	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Пока"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем условие до токена "Цикл"
	Условие = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Цикл"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Цикл" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Цикл' после условия, найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Цикл"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело цикла до "КонецЦикла"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецЦикла", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "КонецЦикла"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "КонецЦикла" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'КонецЦикла', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "КонецЦикла"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Создаем блок цикла Пока
	Возврат СоздатьБлокПока(Условие, Тело);

КонецФункции

// Функция разбирает конструкцию Для-По-Цикл-КонецЦикла
// 
// Возвращаемое значение:
// Структура - блок цикла Для
Функция РазобратьДля()

	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Для"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем инициализацию до токена "По"
	Инициализация = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "По"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "По" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'По' после инициализации, найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "По"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем конечное значение счетчика до токена "Цикл"
	КонецСчетчика = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Цикл"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Цикл" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Цикл', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Цикл"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело цикла до "КонецЦикла"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецЦикла", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "КонецЦикла"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "КонецЦикла" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'КонецЦикла', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "КонецЦикла"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Создаем блок цикла Для
	Возврат СоздатьБлокДля(Инициализация, КонецСчетчика, Тело);

КонецФункции

// Функция разбирает конструкцию Для-Каждого-Из-Цикл-КонецЦикла
// 
// Возвращаемое значение:
// Структура - блок цикла Для Каждого
Функция РазобратьДляКаждого()

	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Для"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Ищем токен "Каждого", пропуская незначащие токены
	РезультатПоиска = ПолучитьСледующийЗначимыйТокен(ТекущийИндекс);
	
	// Проверяем, что следующий значащий токен это "Каждого"
	Если РезультатПоиска.Токен = "" Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли РезультатПоиска.Токен <> "Каждого" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Каждого', найден '%1' (строка %2)", 
			РезультатПоиска.Токен, 
			ТаблицаТокенов[РезультатПоиска.Индекс].НомерСтроки);
	КонецЕсли;
	
	// Переходим на токен после "Каждого"
	ТекущийИндекс = РезультатПоиска.Индекс + 1;
	
	// Разбираем элемент до токена "Из"
	Элемент = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Из"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Из" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Из', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Из"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем коллекцию до токена "Цикл"
	Коллекция = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Цикл"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Цикл" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Цикл', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Цикл"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело цикла до "КонецЦикла"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецЦикла", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "КонецЦикла"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "КонецЦикла" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'КонецЦикла', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "КонецЦикла"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Создаем блок цикла Для Каждого
	Возврат СоздатьБлокДляКаждого(Элемент, Коллекция, Тело);

КонецФункции

// Функция разбирает конструкцию Попытка-Исключение-КонецПопытки
// 
// Возвращаемое значение:
// Структура - блок обработки исключений
Функция РазобратьПопытку()

	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Попытка"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело попытки до токена "Исключение"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("Исключение", Истина);
	ТелоПопытки = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "Исключение"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Исключение" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Исключение', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Исключение"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело обработки исключения до "КонецПопытки"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецПопытки", Истина);
	ТелоИсключения = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "КонецПопытки"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "КонецПопытки" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'КонецПопытки', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "КонецПопытки"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Создаем блок попытки
	Возврат СоздатьБлокПопытка(ТелоПопытки, ТелоИсключения);

КонецФункции

#КонецОбласти

