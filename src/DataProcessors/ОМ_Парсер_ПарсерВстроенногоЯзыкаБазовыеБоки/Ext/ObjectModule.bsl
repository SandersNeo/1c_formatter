// Репозиторий проекта: 
// https://github.com/vladimir-kharin/1c_formatter
// 
// Харин Владимир (С) 2025. https://vharin.ru
// Telegram - https://t.me/vladimir_kharin

// Парсер встроенного языка 1С (на базовые блоки)

// Глобальные переменные
Перем ТекущийИндекс; // Индекс текущего обрабатываемого токена
Перем ТаблицаТокенов; // Таблица токенов для обработки
Перем ВсегоТокенов; // Общее количество токенов

// Функция возвращает структуру, описывающую корневой блок кода
//
// Параметры:
//  Тело - Массив - содержимое блока кода
//
// Возвращаемое значение:
//  Структура - корневой блок кода
//
Функция СоздатьБлокКода(Элементы = Неопределено) Экспорт
	Если Элементы = Неопределено Тогда
		Элементы = Новый Массив;
	КонецЕсли;
	
	Возврат Новый Структура(
		"ВидБлока, Элементы",
		"БлокКода", Элементы
	);
КонецФункции

// Функция возвращает структуру, описывающую блок логической строки
//
// Параметры:
//  НачИндекс - Число - индекс первого токена блока
//  КонИндекс - Число - индекс последнего токена блока
//
// Возвращаемое значение:
//  Структура - блок логической строки
//
Функция СоздатьБлокЛогическойСтроки(НачИндекс, КонИндекс) Экспорт
	Возврат Новый Структура(
		"ВидБлока, НачИндекс, КонИндекс",
		"ЛогическаяСтрока", НачИндекс, КонИндекс
	);
КонецФункции

// Функция возвращает структуру, описывающую блок комментария
//
// Параметры:
//  НачИндекс - Число - индекс первого токена блока
//  КонИндекс - Число - индекс последнего токена блока
//
// Возвращаемое значение:
//  Структура - блок комментария
//
Функция СоздатьБлокКомментария(НачИндекс, КонИндекс) Экспорт
	Возврат Новый Структура(
		"ВидБлока, НачИндекс, КонИндекс",
		"Комментарий", НачИндекс, КонИндекс
	);
КонецФункции

// Функция возвращает структуру, описывающую блок пустой строки
//
// Параметры:
//  НачИндекс - Число - индекс первого токена блока
//  КонИндекс - Число - индекс последнего токена блока
//
// Возвращаемое значение:
//  Структура - блок пустой строки
//
Функция СоздатьБлокПустойСтроки(НачИндекс, КонИндекс) Экспорт
	Возврат Новый Структура(
		"ВидБлока, НачИндекс, КонИндекс",
		"ПустаяСтрока", НачИндекс, КонИндекс
	);
КонецФункции

// Функция возвращает структуру, описывающую блок условия Если
//
// Параметры:
//  Условие - Структура - блок логической строки с условием
//  Тело - Структура - блок кода, содержащий тело условия
//  ВеткиИначе - Массив - массив блоков ИначеЕсли и Иначе
//
// Возвращаемое значение:
//  Структура - блок условия Если
//
Функция СоздатьБлокЕсли(Условие, Тело = Неопределено, ВеткиИначе = Неопределено) Экспорт
	Если Тело = Неопределено Тогда
		Тело = СоздатьБлокКода();
	КонецЕсли;
	
	Если ВеткиИначе = Неопределено Тогда
		ВеткиИначе = Новый Массив;
	КонецЕсли;
	
	Возврат Новый Структура(
		"ВидБлока, Условие, Тело, ВеткиИначе",
		"Если", Условие, Тело, ВеткиИначе
	);
КонецФункции

// Функция возвращает структуру, описывающую блок условия ИначеЕсли
//
// Параметры:
//  Условие - Структура - блок логической строки с условием
//  Тело - Структура - блок кода, содержащий тело условия
//
// Возвращаемое значение:
//  Структура - блок условия ИначеЕсли
//
Функция СоздатьБлокИначеЕсли(Условие, Тело = Неопределено) Экспорт
	Если Тело = Неопределено Тогда
		Тело = СоздатьБлокКода();
	КонецЕсли;
	
	Возврат Новый Структура(
		"ВидБлока, Условие, Тело",
		"ИначеЕсли", Условие, Тело
	);
КонецФункции

// Функция возвращает структуру, описывающую блок условия Иначе
//
// Параметры:
//  Тело - Структура - блок кода, содержащий тело условия
//
// Возвращаемое значение:
//  Структура - блок условия Иначе
//
Функция СоздатьБлокИначе(Тело = Неопределено) Экспорт
	Если Тело = Неопределено Тогда
		Тело = СоздатьБлокКода();
	КонецЕсли;
	
	Возврат Новый Структура(
		"ВидБлока, Тело",
		"Иначе", Тело
	);
КонецФункции

// Функция возвращает структуру, описывающую блок цикла Пока
//
// Параметры:
//  Условие - Структура - блок логической строки с условием
//  Тело - Структура - блок кода, содержащий тело цикла
//
// Возвращаемое значение:
//  Структура - блок цикла Пока
//
Функция СоздатьБлокПока(Условие, Тело = Неопределено) Экспорт
	Если Тело = Неопределено Тогда
		Тело = СоздатьБлокКода();
	КонецЕсли;
	
	Возврат Новый Структура(
		"ВидБлока, Условие, Тело",
		"Пока", Условие, Тело
	);
КонецФункции

// Функция возвращает структуру, описывающую блок цикла Для
//
// Параметры:
//  Инициализация - Структура - блок логической строки с инициализацией счетчика
//  КонецСчетчика - Структура - блок логической строки с конечным значением счетчика
//  Тело - Структура - блок кода, содержащий тело цикла
//
// Возвращаемое значение:
//  Структура - блок цикла Для
//
Функция СоздатьБлокДля(Инициализация, КонецСчетчика, Тело = Неопределено) Экспорт
	Если Тело = Неопределено Тогда
		Тело = СоздатьБлокКода();
	КонецЕсли;
	
	Возврат Новый Структура(
		"ВидБлока, Инициализация, КонецСчетчика, Тело",
		"Для", Инициализация, КонецСчетчика, Тело
	);
КонецФункции

// Функция возвращает структуру, описывающую блок цикла Для Каждого
//
// Параметры:
//  Элемент - Структура - блок логической строки с переменной элемента
//  Коллекция - Структура - блок логической строки с коллекцией
//  Тело - Структура - блок кода, содержащий тело цикла
//
// Возвращаемое значение:
//  Структура - блок цикла Для Каждого
//
Функция СоздатьБлокДляКаждого(Элемент, Коллекция, Тело = Неопределено) Экспорт
	Если Тело = Неопределено Тогда
		Тело = СоздатьБлокКода();
	КонецЕсли;
	
	Возврат Новый Структура(
		"ВидБлока, Элемент, Коллекция, Тело",
		"ДляКаждого", Элемент, Коллекция, Тело
	);
КонецФункции

// Функция возвращает структуру, описывающую блок обработки исключений
//
// Параметры:
//  ТелоПопытки - Структура - блок кода, содержащий тело попытки
//  ТелоИсключения - Структура - блок кода, содержащий обработку исключения
//
// Возвращаемое значение:
//  Структура - блок обработки исключений
//
Функция СоздатьБлокПопытка(ТелоПопытки = Неопределено, ТелоИсключения = Неопределено) Экспорт
	Если ТелоПопытки = Неопределено Тогда
		ТелоПопытки = СоздатьБлокКода();
	КонецЕсли;
	
	Если ТелоИсключения = Неопределено Тогда
		ТелоИсключения = СоздатьБлокКода();
	КонецЕсли;
	
	Возврат Новый Структура(
		"ВидБлока, ТелоПопытки, ТелоИсключения",
		"Попытка", ТелоПопытки, ТелоИсключения
	);
КонецФункции

Функция Разобрать(Токены) Экспорт
    ТаблицаТокенов = Токены;
    ВсегоТокенов = ТаблицаТокенов.Количество();
    ТекущийИндекс = 1;

    Возврат РазобратьБлокКода(Новый Структура("КонецТекста"));
КонецФункции

Функция РазобратьБлокКода(СтруктураЗавершающиеТокены)
	Блок = СоздатьБлокКода();
	
	Пока ТекущийИндекс < ВсегоТокенов Цикл
		ПропуститьТочкуСЗапятой();
		
		ТекущийТокен = ТаблицаТокенов[ТекущийИндекс].Токен;
		
		// Проверяем на завершающий токен
		Если СтруктураЗавершающиеТокены <> Неопределено 
			И СтруктураЗавершающиеТокены.Свойство(ТекущийТокен) Тогда
			Возврат Блок;
		КонецЕсли;
		
		Если ТекущийТокен = "Комментарий" Тогда
			БлокКомментария = РазобратьКомментарий();
			Блок.Элементы.Добавить(БлокКомментария);
		ИначеЕсли ТекущийТокен = "ПустаяСтрока" Тогда
			БлокПустой = РазобратьПустыеСтроки();
			Блок.Элементы.Добавить(БлокПустой);
        ИначеЕсли ТекущийТокен = "Если" Тогда
			БлокУсловия = РазобратьЕсли();
			Блок.Элементы.Добавить(БлокУсловия);
		ИначеЕсли ТекущийТокен = "Пока" Тогда
			БлокЦикла = РазобратьПока();
			Блок.Элементы.Добавить(БлокЦикла);
		ИначеЕсли ТекущийТокен = "Для" Тогда
			РезультатПоиска = ПолучитьСледующийЗначимыйТокен(ТекущийИндекс + 1);
			Если РезультатПоиска.Токен = "Каждого" Тогда
				БлокЦикла = РазобратьДляКаждого();
			Иначе
				БлокЦикла = РазобратьДля();
			КонецЕсли;
			Блок.Элементы.Добавить(БлокЦикла);
		ИначеЕсли ТекущийТокен = "Попытка" Тогда
			БлокПопытки = РазобратьПопытку();
			Блок.Элементы.Добавить(БлокПопытки);
        Иначе
	    	ЛогическаяСтрока = РазобратьЛогическуюСтроку();
		    Блок.Элементы.Добавить(ЛогическаяСтрока);
        КонецЕсли;
    КонецЦикла;
	
	Возврат Блок;
КонецФункции

// Процедура пропускает токен точки с запятой, если он следующий
//
Процедура ПропуститьТочкуСЗапятой()
	Пока ТекущийИндекс < ВсегоТокенов И ТаблицаТокенов[ТекущийИндекс].Токен = "ТочкаСЗапятой" Цикл
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
КонецПроцедуры

// Функция получает следующий значимый токен, пропуская комментарии и пустые строки
//
// Параметры:
//  НачальныйИндекс - Число - индекс, с которого начинается поиск
//
// Возвращаемое значение:
//  Структура - структура с информацией о найденном токене:
//    Токен - Строка - найденный токен или пустая строка, если достигнут конец таблицы токенов
//    Индекс - Число - индекс найденного токена или -1, если токен не найден
//
Функция ПолучитьСледующийЗначимыйТокен(НачальныйИндекс)
	Индекс = НачальныйИндекс;
	
	Пока Индекс < ВсегоТокенов Цикл
		ТекущийТокен = ТаблицаТокенов[Индекс].Токен;
		Если ТекущийТокен <> "Комментарий" И ТекущийТокен <> "ПустаяСтрока" Тогда
			Возврат Новый Структура("Токен, Индекс", ТекущийТокен, Индекс);
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат Новый Структура("Токен, Индекс", "", -1);
КонецФункции

// Функция получает предыдущий значимый токен, пропуская комментарии и пустые строки
//
// Параметры:
//  НачальныйИндекс - Число - индекс, с которого начинается поиск в обратном направлении
//  МинимальныйИндекс - Число - минимальный индекс, до которого производится поиск (по умолчанию 0)
//
// Возвращаемое значение:
//  Структура - структура с информацией о найденном токене:
//    Токен - Строка - найденный токен или пустая строка, если достигнут начало таблицы токенов
//    Индекс - Число - индекс найденного токена или -1, если токен не найден
//
Функция ПолучитьПредыдущийЗначимыйТокен(НачальныйИндекс, МинимальныйИндекс = 0)
	Индекс = НачальныйИндекс;
	
	Пока Индекс >= МинимальныйИндекс Цикл
		ТекущийТокен = ТаблицаТокенов[Индекс].Токен;
		Если ТекущийТокен <> "Комментарий" И ТекущийТокен <> "ПустаяСтрока" Тогда
			Возврат Новый Структура("Токен, Индекс", ТекущийТокен, Индекс);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
	Возврат Новый Структура("Токен, Индекс", "", -1);
КонецФункции

// Функция разбирает непрерывный блок комментариев
//
// Возвращаемое значение:
//  Структура - блок комментария
//
Функция РазобратьКомментарий()
	НачИндекс = ТекущийИндекс;
	
	// Ищем последовательные комментарии
	Пока ТекущийИндекс < ВсегоТокенов И ТаблицаТокенов[ТекущийИндекс].Токен = "Комментарий" Цикл
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	КонИндекс = ТекущийИндекс - 1;
	
	// Создаем блок комментария
	Возврат СоздатьБлокКомментария(НачИндекс, КонИндекс);
КонецФункции

// Функция разбирает непрерывный блок пустых строк
//
// Возвращаемое значение:
//  Структура - блок пустых строк
//
Функция РазобратьПустыеСтроки()
	НачИндекс = ТекущийИндекс;
	
	// Ищем последовательные пустые строки
	Пока ТекущийИндекс < ВсегоТокенов И ТаблицаТокенов[ТекущийИндекс].Токен = "ПустаяСтрока" Цикл
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	КонИндекс = ТекущийИндекс - 1;
	
	// Создаем блок пустых строк
	Возврат СоздатьБлокПустойСтроки(НачИндекс, КонИндекс);
КонецФункции

// Функция разбирает логическую строку
//
// Возвращаемое значение:
//  Структура - блок логической строки
//
Функция РазобратьЛогическуюСтроку()
	НачИндекс = ТекущийИндекс;
	ЭтоИнструкцияПрепроцессора = Ложь;
	
	// Проверяем, является ли токен инструкцией препроцессора
	ТекущийТокен = ТаблицаТокенов[ТекущийИндекс].Токен;
	ЭтоИнструкцияПрепроцессора = (Лев(ТекущийТокен, 1) = "_");
	
	ТекущийНомерСтроки = ТаблицаТокенов[ТекущийИндекс].НомерСтроки;
	
	// Список завершающих токенов
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("ТочкаСЗапятой", Истина);
	ЗавершающиеТокены.Вставить("ИначеЕсли", Истина);
	ЗавершающиеТокены.Вставить("Иначе", Истина);
	ЗавершающиеТокены.Вставить("КонецЕсли", Истина);
	ЗавершающиеТокены.Вставить("КонецЦикла", Истина);
	ЗавершающиеТокены.Вставить("КонецТекста", Истина);
	ЗавершающиеТокены.Вставить("Из", Истина);
	ЗавершающиеТокены.Вставить("По", Истина);
	ЗавершающиеТокены.Вставить("Цикл", Истина);
	ЗавершающиеТокены.Вставить("Тогда", Истина);
	
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Обрабатываем токены до завершающего или до конца строки для препроцессора
	Пока ТекущийИндекс < ВсегоТокенов Цикл
		ТекущийТокен = ТаблицаТокенов[ТекущийИндекс].Токен;
		
		// Проверка для инструкций препроцессора - завершаем при смене строки
		Если ЭтоИнструкцияПрепроцессора И ТаблицаТокенов[ТекущийИндекс].НомерСтроки <> ТекущийНомерСтроки Тогда
			Прервать;
		КонецЕсли;
		
		// Проверка на завершающие токены для обычных строк
		Если НЕ ЭтоИнструкцияПрепроцессора И ЗавершающиеТокены.Свойство(ТекущийТокен) Тогда
            // Если текущий токен - Метка, включаем его в строку и завершаем
            Если ТекущийТокен = "Метка" Тогда
                ТекущийИндекс = ТекущийИндекс + 1;
            КонецЕсли;
			Прервать;
		КонецЕсли;
		
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	КонИндекс = ТекущийИндекс - 1;

	// Сдвигаем конечный индекс к последнему значащему токену (если в конце - комментарии или пустые строки)
	РезультатПоиска = ПолучитьПредыдущийЗначимыйТокен(КонИндекс, НачИндекс);
	Если РезультатПоиска.Индекс <> -1 Тогда
		КонИндекс = РезультатПоиска.Индекс;
		ТекущийИндекс = КонИндекс + 1;
	КонецЕсли;

	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Создаем блок логической строки
	Возврат СоздатьБлокЛогическойСтроки(НачИндекс, КонИндекс);
КонецФункции

// Функция разбирает конструкцию Если-Тогда-ИначеЕсли-Иначе-КонецЕсли
//
// Возвращаемое значение:
//  Структура - блок условия Если
//
Функция РазобратьЕсли()
	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Если"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем условие до токена "Тогда"
	Условие = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Тогда"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
    ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Тогда" Тогда
		ВызватьИсключение СтрШаблон(
            "Ожидается токен 'Тогда' после условия, найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
            ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Тогда"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело условия до веток "ИначеЕсли", "Иначе" или "КонецЕсли"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("ИначеЕсли", Истина);
	ЗавершающиеТокены.Вставить("Иначе", Истина);
	ЗавершающиеТокены.Вставить("КонецЕсли", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Обрабатываем ветки ИначеЕсли и Иначе
	ВеткиИначе = Новый Массив;
	
	Пока ТекущийИндекс < ВсегоТокенов Цикл
		ТекущийТокен = ТаблицаТокенов[ТекущийИндекс].Токен;
		
		Если ТекущийТокен = "ИначеЕсли" Тогда
			ВеткаИначеЕсли = РазобратьИначеЕсли();
			ВеткиИначе.Добавить(ВеткаИначеЕсли);
		ИначеЕсли ТекущийТокен = "Иначе" Тогда
			ВеткаИначе = РазобратьИначе();
			ВеткиИначе.Добавить(ВеткаИначе);
		ИначеЕсли ТекущийТокен = "КонецЕсли" Тогда
			// Пропускаем токен "КонецЕсли"
			ТекущийИндекс = ТекущийИндекс + 1;
			
			// Пропускаем точку с запятой
			ПропуститьТочкуСЗапятой();
			
			Прервать;
		Иначе
			ВызватьИсключение СтрШаблон(
				"Ожидается 'ИначеЕсли', 'Иначе' или 'КонецЕсли', найден '%1' (строка %2)",
				ТекущийТокен, 
				ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
		КонецЕсли;
	КонецЦикла;
	
	// Проверка на наличие КонецЕсли
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
 	КонецЕсли;
	
	// Создаем блок условия Если
	Возврат СоздатьБлокЕсли(Условие, Тело, ВеткиИначе);
КонецФункции

// Функция разбирает конструкцию ИначеЕсли-Тогда
//
// Возвращаемое значение:
//  Структура - блок условия ИначеЕсли
//
Функция РазобратьИначеЕсли()
	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "ИначеЕсли"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем условие до токена "Тогда"
	Условие = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Тогда"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Тогда" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Тогда' после условия, найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Тогда"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело условия до следующих веток или "КонецЕсли"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("ИначеЕсли", Истина);
	ЗавершающиеТокены.Вставить("Иначе", Истина);
	ЗавершающиеТокены.Вставить("КонецЕсли", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Создаем блок условия ИначеЕсли
	Возврат СоздатьБлокИначеЕсли(Условие, Тело);
КонецФункции

// Функция разбирает конструкцию Иначе
//
// Возвращаемое значение:
//  Структура - блок условия Иначе
//
Функция РазобратьИначе()
	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Иначе"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело условия до "КонецЕсли"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецЕсли", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Создаем блок условия Иначе
	Возврат СоздатьБлокИначе(Тело);
КонецФункции

// Функция разбирает конструкцию Пока-Цикл-КонецЦикла
//
// Возвращаемое значение:
//  Структура - блок цикла Пока
//
Функция РазобратьПока()
	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Пока"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем условие до токена "Цикл"
	Условие = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Цикл"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Цикл" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Цикл' после условия, найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Цикл"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело цикла до "КонецЦикла"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецЦикла", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "КонецЦикла"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "КонецЦикла" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'КонецЦикла', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "КонецЦикла"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Создаем блок цикла Пока
	Возврат СоздатьБлокПока(Условие, Тело);
КонецФункции

// Функция разбирает конструкцию Для-По-Цикл-КонецЦикла
//
// Возвращаемое значение:
//  Структура - блок цикла Для
//
Функция РазобратьДля()
	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Для"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем инициализацию до токена "По"
	Инициализация = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "По"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "По" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'По' после инициализации, найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "По"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем конечное значение счетчика до токена "Цикл"
	КонецСчетчика = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Цикл"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Цикл" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Цикл', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Цикл"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело цикла до "КонецЦикла"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецЦикла", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "КонецЦикла"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "КонецЦикла" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'КонецЦикла', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "КонецЦикла"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Создаем блок цикла Для
	Возврат СоздатьБлокДля(Инициализация, КонецСчетчика, Тело);
КонецФункции

// Функция разбирает конструкцию Для-Каждого-Из-Цикл-КонецЦикла
//
// Возвращаемое значение:
//  Структура - блок цикла Для Каждого
//
Функция РазобратьДляКаждого()
	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Для"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Ищем токен "Каждого", пропуская незначащие токены
	РезультатПоиска = ПолучитьСледующийЗначимыйТокен(ТекущийИндекс);
	
	// Проверяем, что следующий значащий токен это "Каждого"
	Если РезультатПоиска.Токен = "" Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли РезультатПоиска.Токен <> "Каждого" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Каждого', найден '%1' (строка %2)", 
			РезультатПоиска.Токен, 
			ТаблицаТокенов[РезультатПоиска.Индекс].НомерСтроки);
	КонецЕсли;
	
	// Переходим на токен после "Каждого"
	ТекущийИндекс = РезультатПоиска.Индекс + 1;
	
	// Разбираем элемент до токена "Из"
	Элемент = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Из"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Из" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Из', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Из"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем коллекцию до токена "Цикл"
	Коллекция = РазобратьЛогическуюСтроку();
	
	// Проверяем наличие токена "Цикл"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Цикл" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Цикл', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Цикл"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело цикла до "КонецЦикла"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецЦикла", Истина);
	Тело = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "КонецЦикла"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "КонецЦикла" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'КонецЦикла', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "КонецЦикла"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Создаем блок цикла Для Каждого
	Возврат СоздатьБлокДляКаждого(Элемент, Коллекция, Тело);
КонецФункции

// Функция разбирает конструкцию Попытка-Исключение-КонецПопытки
//
// Возвращаемое значение:
//  Структура - блок обработки исключений
//
Функция РазобратьПопытку()
	// Сохраняем начальный индекс
	НачИндекс = ТекущийИндекс;
	
	// Пропускаем токен "Попытка"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело попытки до токена "Исключение"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("Исключение", Истина);
	ТелоПопытки = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "Исключение"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "Исключение" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'Исключение', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "Исключение"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Разбираем тело обработки исключения до "КонецПопытки"
	ЗавершающиеТокены = Новый Структура;
	ЗавершающиеТокены.Вставить("КонецПопытки", Истина);
	ТелоИсключения = РазобратьБлокКода(ЗавершающиеТокены);
	
	// Проверяем наличие токена "КонецПопытки"
	Если ТекущийИндекс >= ВсегоТокенов Тогда
		ВызватьИсключение "Неожиданный конец текста";
	ИначеЕсли ТаблицаТокенов[ТекущийИндекс].Токен <> "КонецПопытки" Тогда
		ВызватьИсключение СтрШаблон(
			"Ожидается токен 'КонецПопытки', найден '%1' (строка %2)", 
			ТаблицаТокенов[ТекущийИндекс].Токен, 
			ТаблицаТокенов[ТекущийИндекс].НомерСтроки);
	КонецЕсли;
	
	// Пропускаем токен "КонецПопытки"
	ТекущийИндекс = ТекущийИндекс + 1;
	
	// Пропускаем точку с запятой
	ПропуститьТочкуСЗапятой();
	
	// Создаем блок попытки
	Возврат СоздатьБлокПопытка(ТелоПопытки, ТелоИсключения);
КонецФункции
